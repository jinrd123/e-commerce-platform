# 项目结构分析

* node_modules文件夹：项目依赖文件夹

* public文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。

* src文件夹（程序员源代码文件夹）：
  * assets文件夹：一般也是放置静态资源（一般放置多个组件公用的静态资源），需要注意，放置在assets文件夹里面静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包JS文件里面
  * components文件夹：一般放置的是非路由组件（全局组件）。
  * App.vue：唯一的根组件
  * main.js：程序的入口文件，也是整个程序当中最先执行的文件

* babel.config.js：配置文件（babel相关，类似于翻译官，比如可以把es6的语法翻译成es5的语法，让兼容性更好）

* package.json文件：类似于项目的“身份证”，记录项目叫什么、项目中有哪些依赖、项目怎么运行等相关信息

* package-lock.json文件：缓存性文件，比如依赖在哪里下载在的等一些过程信息，而且发现依赖第一次下载比较慢，后来比较快，就是因为这个文件有一部分缓存信息。

* READMD.md：说明文件

# 项目的其他配置

## 2.1项目运行起来的时候，让浏览器自动打开

---package.json
    script配置项serve配置最后加--open
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
---node_modules/@vue/cli-service/lib/commands/serve.js
    host的默认值改为'127.0.0.1'
    const defaults = {
    host: '127.0.0.1',
    port: 8080,
    https: false
    }

## 2.2eslint校验功能关闭

  ---在根目录下，创建一个vue.config.js
    设置lintOnSave:false

## 2.3src文件夹简写方法，配置别名。

jsconfig.json配置别名@（@代表src文件夹，这样将来文件过多方便寻找）

## 2.4安装vue-router等依赖时的两种方式：

* 在终端里npm install vue-router，但不知为什么可能是依赖之间不兼容的问题报错
* 在package.json里写好"dependencies"配置项：
      "dependencies": {
          "core-js": "^3.8.3",
          "less": "^4.1.3",
          "less-loader": "^11.0.0",
          "vue": "^2.6.14",
          "vue-router": "^3.5.3"
      },
      然后终端里直接npm install：安装项目的所有依赖，这样可以更明确地指定安装的所有依赖。

# 项目处理技巧

## 1.利用路由元信息控制Footer组件的隐藏与显示

Footer组件：在Home、Search组件显示时显示Footer组件，在登录和注册时隐藏Footer组件。

把Home和Search的元信息（meta项）中的show属性设置为true，登陆组件和注册组件的show属性设置为false

利用v-show结合路由的元信息进行控制：`<Footer v-show="$route.meta.show"><Footer>`

($route就是指**当前路径**对应的**路由组件**的信息，理解：每个路由组件都有对应的path，所以path和路由组件是一一对应的)

## 2.路由知识点复习

### 路由转跳的两种方式：

* 声明式导航：router-link（务必要有to属性），可以实现路由的转跳
* 编程式导航：利用的是组件实例的$router.push|replace方法，可以实现路由的转跳

### 路由传参的两种写法：

* params参数：属于路径当中的一部分(配置路由的时候在path配置项里体现“占位”)，需要注意，在配置路由的时候，需要占位，路由配置的时候：`path:"/home/:keyword",`

* query参数，不属于路径当中的一部分，类似于ajax中的queryString，配置路由的时候不需要占位,传递的时候直接:`/home?k=v&k2=v2`

* 编程式路由导航传递参数的三种写法：

  * 1.字符串形式：`this.$router.push('/search' + this.mydata + "?k=" + this.mydata.toUpperCase());`
  * 2.模板字符串：

  ~~~js
  this.$router.push(`/search/${this.mydata}?k=${this.mydata.toUpperCase}`);
  ~~~
  * 3.对象（但如果有params参数，就必须用组件的name配置，这里的name是路由配置文件中的name，不是组件本身的name，不能用path）

  ~~~js
  this.$router.push({
      name:"search",
      params:{
          mydata,
      },
      query:{
          k:this.mydata.toUpperCase(),
      }
  })
  ~~~

### 路由传参的面试题

1. 路由传递参数（对象写法）path是否可以结合params参数一起使用？（不可以，path必须换成name）
2. 如何指定params参数可传可不传？

情景：配置路由的时候，写了params参数的占位，但是路由跳转的时候不传递，那么路径就会出现问题，我们需要在占位的后面加一个“？”表示这个params参数可以传也可以不传。

3. 当某个params参数可传可不传时，我们给这个params参数传递了一个空字符串，这时候就会出现bug，路径又会出现问题，我们只需令空字符串或上undefined即可解决

~~~js
this.$router.push({
    name:"search",
    params:{
        mydata:""||undefined,
    },
    query:{
        k:this.mydata.toUpperCase(),
    }
})
~~~

4. 路由组件利用props传递数据？

* 路由配置文件中：`props:true`,就是说这个路由组件就收到的params参数可以用props接收
* `props:{a:1,b:2}`就是说额外传递一个a和b，然后路由组件中可以用props接收到a和b
* `props:()=>{return {keyword:$route.params.keyword,k:$route.query.k};}`然后路由组件中就可以用props接收到keyword和k，这种函数写法相返回什么都可以，对应路由组件中就接收什么。

## 3.编程式路由导航（由home到search时）重复多次点击转跳会导致NavigationDuplicated的错误警告

声明式路由导航没有这个问题，因为vue-router底层已经处理好了；但编程式路由导航会出现这个问题，因为"vue-router": "^3.5.3"引入了promise，导致`$router.push`返回一个promise对象，所以其实`$router.push`需要接收三个参数，除了第一个参数为指定路径和参数的字符串之外，还需要接收promise的成功回调和失败回调，底层出现这个bug的原理就是因为没有指定成功与失败的回调，导致一直进入现在已经在的路径无法处理。所以我们可以在调用`$router.push`时传入成功与失败的回调函数，或者**对$router的`push`和`replace`方法进行重写（封装）**，让push方法可以只接收第一个参数而不报错。

路由配置文件中：

~~~js
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);

//先把VueRouter原型对象的push方法的函数体保存一份
let originPush = VueRouter.prototype.push;

//重写push|replace
//参数结构与原来的push保持一致，第一个表示跳转的目标位置，后面俩为回调
VueRouter.prototype.push = function(location,resolve,reject) {
    if(resolve && reject) {
        originPush.call(this,location,resolve,reject);
    }else {
        originPush.call(this,location,()=>{},()=>{});
    }
}
~~~

### 重写push方法的注意点：

* 在组件js中利用$router去使用push其实就是访问Vuerouter原型对象上的push方法（Vuerouter是我们引入的路由器构造函数，$router其实就是一个Vuerouter的实例），我们通过originPush保存了原来push方法的函数体，但这个originPush不属于任何对象了（理解可看”前端面试-this“），在调用originPush时直接属于window，所以在重写的函数体中需要用`call`方法让push的this为Vuerouter的原型对象，才能达到路由跳转的功能，因为直接调用originPush的话，this是window，里面的逻辑肯定不对。



## 4.三级联动组件的拆分思路

因为在Search、Home等多个组件中都在使用，所以我们把它注册为全局组件。（好处：只需注册一次，项目的任意位置使用）

在入口文件（main.js中）引入全局组件

~~~js
//三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav';
//Vue.component注册全局组件，第一个参数指定想要注册的名字，第二个参数指定组件的信息
//因为我们在Home组件下，已经写了TypeNav组件，所以我们这在里注册全局组件只需要用Home下的TypeNav即可，所以要注册的全局组件的名字就是TypeNav.name，组件内容就是TypeNav
Vue.component(TypeNav.name,TypeNav);
~~~

## 5.axios二次封装

### axios二次封装的意义：

利用请求拦截器和响应拦截器：

* 请求拦截器：发请求之前处理一些业务
* 响应拦截器：服务器数据返回以后处理一些业务

### 文件位置：

项目当中src文件夹下有一个api文件夹，里面存放关于axios的相关文件

### @/api/request.js:

~~~js
//对于axios进行二次封装
import axios from "axios";

//1.利用axios对象的方法create创建一个axios实例，而且我们create一个axios实例的时候可以进行配置
const requests = axios.create({
    //给服务器地址增加上默认路径api
    baseURL:"/api",
    //请求超过5s就默认失败
    timeout:5000
})

//请求拦截器
requests.interceptors.request.use((config)=>{
    //config:配置对象，对象里面有一个属性很重要：headers--请求头
    return config;
});

//响应拦截器
requests.interceptors.response.use((res)=>{
    //成功的回调函数，接收服务器发来的响应数据
    return res.data;
},(error)=>{
    //失败的回调函数
    //终结promise链
    return Promise.reject(new Error('faile'));
});

//暴露出处理好的axios实例对象requests
export default requests;
~~~

## 6.项目接口统一管理

如果项目很小，完全可以在组件的生命周期中发请求，得到数据之后存放在data中，但如果项目很大，成千上百个组件中都写了`axios.get('xxx')`接口一旦改变，每一个请求都得改过来，所以需要接口统一管理，我们只需在统一管理的位置改一下就完成了所有组件的接口地址更改。

在api文件夹下，创建文件index.js，然后里面封装一些向对应接口发请求的方法，并且暴露这些方法，然后组件中需要发请求的时候引入方法使用即可。

比如封装请求三级联动导航数据的方法：

~~~js
//@/api/index.js:
//引入封装好的axios--->requests
import requests from "./request";
//箭头函数，函数体发送就是用axios发送请求
export const reqCategoryList = () => requests({
    url:'/product/getBaseCategoryList',
    method:'get',
})

//但这样发请求默认是向咱们前端项目本身的ip地址发送请求，我们要请求远程服务器，但要解决跨域问题：
//webpack为我们提供了“代理服务器”解决跨域问题
//在webpack.config.js中进行配置，这个文件就相当于我们vue项目中的vue.config.js
//vue.config.js中添加“代理”配置
devServer: {
    proxy: {
        //api代表如果前端发送的请求路径中如果有api，那么就把这个请求发送给target对应的服务器（相当于webpack提供的服务器对真正的服务器进行代理）
        '/api': {
            target:'http://gmall-h5-api.atguigu.cn'
        }
    }
}
~~~

## 7.请求进度条效果

1. 安装nprogress：`npm install nprogress`
2. 在请求拦截器和响应拦截器中设置进度条开始和进度条结束：

`@/api/request.js:`

~~~js
//引入进度条
import nprogress from 'nprogress';
//引入进度条样式
import 'nprogress/nprogress.css';
//nprogress是一个对象，里面有start方法和done方法，调用使进度条开始和结束，在请求拦截器中start、请求响应拦截器中done即可完成进度条效果
requests.interceptors.request.use((config)=>{
    nprogress.start();
    return config;
});
requests.interceptors.response.use((res)=>{
    nprogress.done();
    return res.data;
},(error)=>{
    return Promise.reject(new Error("faile"));
})
~~~

## 8.安装vuex

~~~js
npm install vuex@3.6.2
~~~

`@/store/index.js:`

~~~js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const state = {};
const mutations = {};
const actions = {};
const getters = {};

export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters,
})
~~~

`main.js:`

~~~js
...
import store from '@/store';
new Vue({
    ...
    //注册仓库，组件实例身上会多一个$store属性
    store,
    ...
})
~~~

### 用vuex的模块化开发：

`@/store/search/index.js:`

~~~js
//search模块的小仓库
const state = {};
const mutations = {};
const actions = {};
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters,
}
~~~

`@/store/index.js:`

~~~js
...
//引入小仓库
import search from './search';

exprot default new Vuex.Store({
	modules: {
        search,
        ...
    }
})
~~~

## 9.动态展示三级联动数据

​	三级联动数据的展示是在页面加载完成时就要呈现给用户的，所以我们选择在TypeNav组件挂载完毕之后（某个生命周期，也可以是created）就去请求数据，给vuex发送请求之后，在vuex中先引入api（接口统一管理文件夹）中定义的请求函数，再在actions中调用获取数据，然后再mutations中修改state中的数据，这里牵扯一个state中数据初始化的问题，我们要看接口返回什么数据，接口返回数组就初始化为数组，返回对象就初始化为一个对象。

​	获取数据之后，就是运用数据去渲染页面了，找准同级结构，然后留下一个结构用v-for遍历数据生成所有同级数据即可。

### 有关请求结构的思考：

我们在vuex的actions中发请求的时候，用的是现成的函数，这个函数在api文件夹中定义，函数体就是用requests（封装的axios）发送一个请求，发请求时用配置对象指定url和method，url不用写全路径，因为这里的url是建立在requests和vue.config.js基础之上的：

* 封装axios生成requests的时候，配置了`baseURL:"/api"`，所以我们发送请求的地址都自动加上/api
* vue.config.js中配置了请求代理服务器：

~~~js
devServer: {
        proxy: {
            '/api': {
                target: 'http://gmall-h5-api.atguigu.cn'
            }
        }
    }
~~~

也就是说，如果我们发送的请求是/api开头，那么默认这个请求是发给target指定的服务器的

所以说，我们在api中定义的请求函数url只写`'/product/getBaseCategoryList'`就相当于先加上了baseURL，然后又因为有了api，所以默认是发给`'http://gmall-h5-api.atguigu.cn'`的请求，最终请求函数相当于用axios给`'http://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList'`发出了请求。

## 10.三级联动动态添加背景颜色

### css方案：

给同一级的结构添加`:hover`样式，设置background-color为某种颜色

### js方案：

对同一级的结构进行编号，用一个`currentIndex`保存鼠标放在了哪一个结构上，然后在标签中给`index===currentIndex`的结构加上样式。

#### vue给标签动态添加样式语法：

`<p :class="{'stylename': true/false}"`

## 11.事件委派处理效果：上方鼠标进入“全部商品分类”但保留相邻元素的背景颜色不消失

如果我们给三级联动中第一级的每一项都添加鼠标离开的监听事件，不光效率低，而且没法做到鼠标进入“全部商品分类”而且保留相邻元素的背景颜色不消失的效果，这时候，我们把“全部商品分类”和三级联动第一级用一个div包裹起来，然后给这个div添加鼠标离开的监听事件，相当于原本属于每一个小盒子和“全部商品分类”的鼠标离开事件委派给了外层的div。（事件委派的生动理解：公司三个员工去公司门口等快递或者把收快递这件事委派给公司前台人员一个人）

## 12.js控制二三级联动导航的显示和隐藏

在以前`display:none`且`:hover`时`display:block`的盒子上用vue动态添加样式：`:style="{display:currentIndex===index?'block':'none'}"`

## 13.三级联动设置节流

利用lodash，lodash里面有各种各样的函数，lodash里的`throttle`就是封装的节流函数，直接引入使用即可。

~~~js
/*引入lodash的全部函数
import _ from "lodash";*/
//按需引入lodash中的节流函数
import throttle from 'lodash/throttle.js';

//组件中：
methods: {
    changeIndex:throttle(function (index) {
        this.currentIndex = index;
    },50),
}
~~~

### methods中的写法的解析：

* 首先在es5中，对象中写方法都是键值对，键加匿名函数的形式，我们熟悉的在methods中写“具名函数+逗号+具名函数”其实是es6的语法，函数名就是键名
* lodash中的throttle函数返回值是一个函数，说白了throttle是制造节流函数的函数，而本身不是节流函数
* 我们上面用了es5中键值对的方法写methods，键是“changeIndex”，值是用throttle生成的一个匿名函数
* 我测试了一下 工厂函数调用 作为 对象中某个键的值 时，执行的时机（throttle的调用作为methods对象中键changeIndex的值），发现**工厂函数的调用在对象初始化时就会调用，生成的函数作为键的值**，测试代码：

~~~js
function test() {
    console.log("生成函数的函数");
    return function() {
        console.log("生成的函数");
    }
}
let obj = {
    name:test(),
}
//执行这段代码就会输出生成函数的函数，说明对象初始化时工厂函数test就执行了。
~~~

* throttle应该是对它第一个参数的封装，模板中给changeIndex传递的参数其实就是传递给throttle的第一个函数参数了，所以上面的index就是模板中传过来的参数。

## 14.三级联动路由跳转

如果选择`router-link`，它的本质就是一个组件，那么在`v-for`生成三级联动的时候，就可能会生成成千上万个`router-link`，也就是成千上万个组件，会占用大量内存，造成卡顿。

所以我们不用声明式导航，选择编程式导航。

然后我们给每一个`<a>`标签都绑定一个点击事件的话，自然性能也不会太好，用**事件委派。即给包裹三级联动的没有进行循环生成的大盒子绑定一个点击监听函数。**但需要解决两个问题：

* 只有点击大盒子里的a标签，我们才进行路由跳转，而不是点击整个大盒子都进行路由跳转。如何判断我们点击的是a标签？确定点击的是a标签之后，又怎么确定是一级a标签还是二级或者三级a标签？
* 路由跳转的时候需要把产品的名字和id传给search组件，如何传参？

我们给一个包含了很多dom元素的大盒子绑定了一个监听事件之后，通过事件的event对象可以获取是哪一个元素被点击了，`event.target`就是被点击的dom元素，比如`<h3 class="fore">...</h3>`这种，然后我们在模板中**给a标签使用自定义属性：**

~~~html
<a :data-categoryName="c1.categoryName">{{c1.categoryName}}</a>
~~~

所谓**自定义属性也就是用v-bind给标签绑定一个":data-"开头的属性**，然后我们如果在js中获得了dom元素，就可以通过dom元素的dataset属性获得一个对象，这个对象里就是所有自定义属性（:data-后面的属性）组成的键值对，我们只需要利用es6的对象解构赋值即可获得dataset里的自定义属性

~~~js
//给外层的大盒子绑定的进行路由转跳的函数
goSearch(event) {
    //通过事件对象的target获得被点击的dom元素
    let element = event.target;
    let {categoryName,category1id,category2id,category3id} = element.dataset;
	//我们只给a标签添加了自定义属性categoryName，先通过有没有categoryName判断点击的是不是a标签
	//然后分别给三级联动的一二三级a标签添加自定义属性category n id，通过这个属性判断是几级的a标签，不同级的a标签传递不同的参数
    if(categoryName) {//如果是a标签
        //开始构造路由转跳的参数
        let location = {name:"search"};
        //构造query参数
        let query = {categoryName: categoryName};
        if(category1id) {
            query.category1id = category1id;
        }else if(category2id) {
            query.category2id = category2id;
        }else {
            query.category3id = category3id;
        }
        location.query = query;
        //路由转跳
        this.$router.push(location);
    }
}
~~~

## 15.search组件中TypeNav组件的三级联动部分进行显示和隐藏

因为不是整个TypeNav的显示和隐藏，所以显示和隐藏的逻辑不能作用于search中的<TypeNav>,必须把显示和隐藏的逻辑写在<TypeNav>组件的内部，通过`this.$route.path`不同区分search中的TypeNav还是Home中的TypeNav，也就是增加逻辑：当`this.$route.path === "/search"`的时候，进行部分的显示和隐藏。

## 16.search组件中三级联动部分从上往下出现的vue动画效果

transition详细博文：[(38条消息) Vue — transition实现过渡动画_@Demi的博客-CSDN博客_vue的transition过渡动画](https://blog.csdn.net/qq_38128179/article/details/118934676)

### vue动画知识点：

vue动画使用条件：给使用了条件渲染（`v-for`/`v-if`)的dom元素或者组件使用<transition>包含，就可以给它添加动画效果：

自动生成几个动画相关的css类：

* `v-enter-active`:dom元素生成的整个阶段的样式，一般可以设置`transition:transform .5s;`表示生成阶段持续0.5s，生成阶段包含开始状态和结束状态，对应类：
  * `v-enter`
  * `v-enter-to`
* `v-leave-active`:dom元素消失的整个阶段的样式，包含消失的开始状态和结束状态：
  * `v-leave`
  * `v-leave-to`

但是<transition>一旦设置的name属性，那么生成的css类名中将用name值代替v。

### 实现分类列表从上往下出现的效果：

~~~html
<transition name="sort">
	<div class="sort" v-show="show">
        ...
    </div>
</transition>
~~~

~~~css
.sort-enter{
    height: 0px;
}
.sort-enter-to{
    height: 461px;
}
.sort-enter-active{
    transition: all .5s linear;
}
~~~

## 17.合并路由转跳时同时传递params参数和query参数（需要保留目前已有的参数）

我们由home组件转跳到search组件时，通过搜索框会传递params参数，通过三级联动分类点击会传递query参数，所以我们要考虑如果目前先点击了三级联动，拥有了query参数，这时点击搜索，需要在保留query参数的条件下增加params参数，同样如果先搜索再点击三级联动，也要保留以前的params参数。

构造push的转跳参数location时：

* 保留已有的params参数：

`location.params = this.$route.params;`

* 保留已有的query参数：

`location.query = this.$route.query;`

plus:这里没必要判断是否拥有params参数或者query参数再添加，比如`if(this.$route.params){location.params = this.$route.params;}`,因为`$route`里不管有没有query参数或者params参数，都有query空对象和params空对象，this.$route.params和this.$route.query都是存在的。