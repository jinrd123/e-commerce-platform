# 项目结构分析

* node_modules文件夹：项目依赖文件夹

* public文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。

* src文件夹（程序员源代码文件夹）：
  * assets文件夹：一般也是放置静态资源（一般放置多个组件公用的静态资源），需要注意，放置在assets文件夹里面静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包JS文件里面
  * components文件夹：一般放置的是非路由组件（全局组件）。
  * App.vue：唯一的根组件
  * main.js：程序的入口文件，也是整个程序当中最先执行的文件

* babel.config.js：配置文件（babel相关，类似于翻译官，比如可以把es6的语法翻译成es5的语法，让兼容性更好）

* package.json文件：类似于项目的“身份证”，记录项目叫什么、项目中有哪些依赖、项目怎么运行等相关信息

* package-lock.json文件：缓存性文件，比如依赖在哪里下载在的等一些过程信息，而且发现依赖第一次下载比较慢，后来比较快，就是因为这个文件有一部分缓存信息。

* READMD.md：说明文件

# 项目的其他配置

## 2.1项目运行起来的时候，让浏览器自动打开

---package.json
    script配置项serve配置最后加--open
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
---node_modules/@vue/cli-service/lib/commands/serve.js
    host的默认值改为'127.0.0.1'
    const defaults = {
    host: '127.0.0.1',
    port: 8080,
    https: false
    }

## 2.2eslint校验功能关闭

  ---在根目录下，创建一个vue.config.js
    设置lintOnSave:false

## 2.3src文件夹简写方法，配置别名。

jsconfig.json配置别名@（@代表src文件夹，这样将来文件过多方便寻找）

## 2.4安装vue-router等依赖时的两种方式：

* 在终端里npm install vue-router，但不知为什么可能是依赖之间不兼容的问题报错
* 在package.json里写好"dependencies"配置项：
      "dependencies": {
          "core-js": "^3.8.3",
          "less": "^4.1.3",
          "less-loader": "^11.0.0",
          "vue": "^2.6.14",
          "vue-router": "^3.5.3"
      },
      然后终端里直接npm install：安装项目的所有依赖，这样可以更明确地指定安装的所有依赖。

# 项目处理技巧

## 1.利用路由元信息控制Footer组件的隐藏与显示

Footer组件：在Home、Search组件显示时显示Footer组件，在登录和注册时隐藏Footer组件。

把Home和Search的元信息（meta项）中的show属性设置为true，登陆组件和注册组件的show属性设置为false

利用v-show结合路由的元信息进行控制：`<Footer v-show="$route.meta.show"><Footer>`

($route就是指**当前路径**对应的**路由组件**的信息，理解：每个路由组件都有对应的path，所以path和路由组件是一一对应的)

## 2.路由知识点复习

### 路由转跳的两种方式：

* 声明式导航：router-link（务必要有to属性），可以实现路由的转跳
* 编程式导航：利用的是组件实例的$router.push|replace方法，可以实现路由的转跳

### 路由传参的两种写法：

* params参数：属于路径当中的一部分(配置路由的时候在path配置项里体现“占位”)，需要注意，在配置路由的时候，需要占位，路由配置的时候：`path:"/home/:keyword",`

* query参数，不属于路径当中的一部分，类似于ajax中的queryString，配置路由的时候不需要占位,传递的时候直接:`/home?k=v&k2=v2`

* 编程式路由导航传递参数的三种写法：

  * 1.字符串形式：`this.$router.push('/search' + this.mydata + "?k=" + this.mydata.toUpperCase());`
  * 2.模板字符串：

  ~~~js
  this.$router.push(`/search/${this.mydata}?k=${this.mydata.toUpperCase}`);
  ~~~
  * 3.对象（但如果有params参数，就必须用组件的name配置，这里的name是路由配置文件中的name，不是组件本身的name，不能用path）

  ~~~js
  this.$router.push({
      name:"search",
      params:{
          mydata,
      },
      query:{
          k:this.mydata.toUpperCase(),
      }
  })
  ~~~

### 路由传参的面试题

1. 路由传递参数（对象写法）path是否可以结合params参数一起使用？（不可以，path必须换成name）
2. 如何指定params参数可传可不传？

情景：配置路由的时候，写了params参数的占位，但是路由跳转的时候不传递，那么路径就会出现问题，我们需要在占位的后面加一个“？”表示这个params参数可以传也可以不传。

3. 当某个params参数可传可不传时，我们给这个params参数传递了一个空字符串，这时候就会出现bug，路径又会出现问题，我们只需令空字符串或上undefined即可解决

~~~js
this.$router.push({
    name:"search",
    params:{
        mydata:""||undefined,
    },
    query:{
        k:this.mydata.toUpperCase(),
    }
})
~~~

4. 路由组件利用props传递数据？

* 路由配置文件中：`props:true`,就是说这个路由组件就收到的params参数可以用props接收
* `props:{a:1,b:2}`就是说额外传递一个a和b，然后路由组件中可以用props接收到a和b
* `props:()=>{return {keyword:$route.params.keyword,k:$route.query.k};}`然后路由组件中就可以用props接收到keyword和k，这种函数写法相返回什么都可以，对应路由组件中就接收什么。

## 3.编程式路由导航（由home到search时）重复多次点击转跳会导致NavigationDuplicated的错误警告

声明式路由导航没有这个问题，因为vue-router底层已经处理好了；但编程式路由导航会出现这个问题，因为"vue-router": "^3.5.3"引入了promise，导致`$router.push`返回一个promise对象，所以其实`$router.push`需要接收三个参数，除了第一个参数为指定路径和参数的字符串之外，还需要接收promise的成功回调和失败回调，底层出现这个bug的原理就是因为没有指定成功与失败的回调，导致一直进入现在已经在的路径无法处理。所以我们可以在调用`$router.push`时传入成功与失败的回调函数，或者**对$router的`push`和`replace`方法进行重写（封装）**，让push方法可以只接收第一个参数而不报错。

路由配置文件中：

~~~js
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);

//先把VueRouter原型对象的push方法的函数体保存一份
let originPush = VueRouter.prototype.push;

//重写push|replace
//参数结构与原来的push保持一致，第一个表示跳转的目标位置，后面俩为回调
VueRouter.prototype.push = function(location,resolve,reject) {
    if(resolve && reject) {
        originPush.call(this,location,resolve,reject);
    }else {
        originPush.call(this,location,()=>{},()=>{});
    }
}
~~~

### 重写push方法的注意点：

* 在组件js中利用$router去使用push其实就是访问Vuerouter原型对象上的push方法（Vuerouter是我们引入的路由器构造函数，$router其实就是一个Vuerouter的实例），我们通过originPush保存了原来push方法的函数体，但这个originPush不属于任何对象了（理解可看”前端面试-this“），在调用originPush时直接属于window，所以在重写的函数体中需要用`call`方法让push的this为Vuerouter的原型对象，才能达到路由跳转的功能，因为直接调用originPush的话，this是window，里面的逻辑肯定不对。



## 4.三级联动组件的拆分思路

因为在Search、Home等多个组件中都在使用，所以我们把它注册为全局组件。（好处：只需注册一次，项目的任意位置使用）

在入口文件（main.js中）引入全局组件

~~~js
//三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav';
//Vue.component注册全局组件，第一个参数指定想要注册的名字，第二个参数指定组件的信息
//因为我们在Home组件下，已经写了TypeNav组件，所以我们这在里注册全局组件只需要用Home下的TypeNav即可，所以要注册的全局组件的名字就是TypeNav.name，组件内容就是TypeNav
Vue.component(TypeNav.name,TypeNav);
~~~

## 5.axios二次封装

### axios二次封装的意义：

利用请求拦截器和响应拦截器：

* 请求拦截器：发请求之前处理一些业务
* 响应拦截器：服务器数据返回以后处理一些业务

### 文件位置：

项目当中src文件夹下有一个api文件夹，里面存放关于axios的相关文件

### @/api/request.js:

~~~js
//对于axios进行二次封装
import axios from "axios";

//1.利用axios对象的方法create创建一个axios实例，而且我们create一个axios实例的时候可以进行配置
const requests = axios.create({
    //给服务器地址增加上默认路径api
    baseURL:"/api",
    //请求超过5s就默认失败
    timeout:5000
})

//请求拦截器
requests.interceptors.request.use((config)=>{
    //config:配置对象，对象里面有一个属性很重要：headers--请求头
    return config;
});

//响应拦截器
requests.interceptors.response.use((res)=>{
    //成功的回调函数，接收服务器发来的响应数据
    return res.data;
},(error)=>{
    //失败的回调函数
    //终结promise链
    return Promise.reject(new Error('faile'));
});

//暴露出处理好的axios实例对象requests
export default requests;
~~~

## 6.项目接口统一管理

如果项目很小，完全可以在组件的生命周期中发请求，得到数据之后存放在data中，但如果项目很大，成千上百个组件中都写了`axios.get('xxx')`接口一旦改变，每一个请求都得改过来，所以需要接口统一管理，我们只需在统一管理的位置改一下就完成了所有组件的接口地址更改。

在api文件夹下，创建文件index.js，然后里面封装一些向对应接口发请求的方法，并且暴露这些方法，然后组件中需要发请求的时候引入方法使用即可。

比如封装请求三级联动导航数据的方法：

~~~js
//@/api/index.js:
//引入封装好的axios--->requests
import requests from "./request";
//箭头函数，函数体发送就是用axios发送请求
export const reqCategoryList = () => requests({
    url:'/product/getBaseCategoryList',
    method:'get',
})

//但这样发请求默认是向咱们前端项目本身的ip地址发送请求，我们要请求远程服务器，但要解决跨域问题：
//webpack为我们提供了“代理服务器”解决跨域问题
//在webpack.config.js中进行配置，这个文件就相当于我们vue项目中的vue.config.js
//vue.config.js中添加“代理”配置
devServer: {
    proxy: {
        //api代表如果前端发送的请求路径中如果有api，那么就把这个请求发送给target对应的服务器（相当于webpack提供的服务器对真正的服务器进行代理）
        '/api': {
            target:'http://gmall-h5-api.atguigu.cn'
        }
    }
}
~~~

## 7.请求进度条效果

1. 安装nprogress：`npm install nprogress`
2. 在请求拦截器和响应拦截器中设置进度条开始和进度条结束：

`@/api/request.js:`

~~~js
//引入进度条
import nprogress from 'nprogress';
//引入进度条样式
import 'nprogress/nprogress.css';
//nprogress是一个对象，里面有start方法和done方法，调用使进度条开始和结束，在请求拦截器中start、请求响应拦截器中done即可完成进度条效果
requests.interceptors.request.use((config)=>{
    nprogress.start();
    return config;
});
requests.interceptors.response.use((res)=>{
    nprogress.done();
    return res.data;
},(error)=>{
    return Promise.reject(new Error("faile"));
})
~~~

## 8.安装vuex

~~~js
npm install vuex@3.6.2
~~~

`@/store/index.js:`

~~~js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const state = {};
const mutations = {};
const actions = {};
const getters = {};

export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters,
})
~~~

`main.js:`

~~~js
...
import store from '@/store';
new Vue({
    ...
    //注册仓库，组件实例身上会多一个$store属性
    store,
    ...
})
~~~

### 用vuex的模块化开发：

`@/store/search/index.js:`

~~~js
//search模块的小仓库
const state = {};
const mutations = {};
const actions = {};
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters,
}
~~~

`@/store/index.js:`

~~~js
...
//引入小仓库
import search from './search';

exprot default new Vuex.Store({
	modules: {
        search,
        ...
    }
})
~~~

## 9.动态展示三级联动数据

​	三级联动数据的展示是在页面加载完成时就要呈现给用户的，所以我们选择在TypeNav组件挂载完毕之后（某个生命周期，也可以是created）就去请求数据，给vuex发送请求之后，在vuex中先引入api（接口统一管理文件夹）中定义的请求函数，再在actions中调用获取数据，然后再mutations中修改state中的数据，这里牵扯一个state中数据初始化的问题，我们要看接口返回什么数据，接口返回数组就初始化为数组，返回对象就初始化为一个对象。

​	获取数据之后，就是运用数据去渲染页面了，找准同级结构，然后留下一个结构用v-for遍历数据生成所有同级数据即可。

### 有关请求结构的思考：

我们在vuex的actions中发请求的时候，用的是现成的函数，这个函数在api文件夹中定义，函数体就是用requests（封装的axios）发送一个请求，发请求时用配置对象指定url和method，url不用写全路径，因为这里的url是建立在requests和vue.config.js基础之上的：

* 封装axios生成requests的时候，配置了`baseURL:"/api"`，所以我们发送请求的地址都自动加上/api
* vue.config.js中配置了请求代理服务器：

~~~js
devServer: {
        proxy: {
            '/api': {
                target: 'http://gmall-h5-api.atguigu.cn'
            }
        }
    }
~~~

也就是说，如果我们发送的请求是/api开头，那么默认这个请求是发给target指定的服务器的

所以说，我们在api中定义的请求函数url只写`'/product/getBaseCategoryList'`就相当于先加上了baseURL，然后又因为有了api，所以默认是发给`'http://gmall-h5-api.atguigu.cn'`的请求，最终请求函数相当于用axios给`'http://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList'`发出了请求。

## 10.三级联动动态添加背景颜色

### css方案：

给同一级的结构添加`:hover`样式，设置background-color为某种颜色

### js方案：

对同一级的结构进行编号，用一个`currentIndex`保存鼠标放在了哪一个结构上，然后在标签中给`index===currentIndex`的结构加上样式。

#### vue给标签动态添加样式语法：

`<p :class="{'stylename': true/false}"`

## 11.事件委派处理效果：上方鼠标进入“全部商品分类”但保留相邻元素的背景颜色不消失

如果我们给三级联动中第一级的每一项都添加鼠标离开的监听事件，不光效率低，而且没法做到鼠标进入“全部商品分类”而且保留相邻元素的背景颜色不消失的效果，这时候，我们把“全部商品分类”和三级联动第一级用一个div包裹起来，然后给这个div添加鼠标离开的监听事件，相当于原本属于每一个小盒子和“全部商品分类”的鼠标离开事件委派给了外层的div。（事件委派的生动理解：公司三个员工去公司门口等快递或者把收快递这件事委派给公司前台人员一个人）

## 12.js控制二三级联动导航的显示和隐藏

在以前`display:none`且`:hover`时`display:block`的盒子上用vue动态添加样式：`:style="{display:currentIndex===index?'block':'none'}"`

## 13.三级联动设置节流

利用lodash，lodash里面有各种各样的函数，lodash里的`throttle`就是封装的节流函数，直接引入使用即可。

~~~js
/*引入lodash的全部函数
import _ from "lodash";*/
//按需引入lodash中的节流函数
import throttle from 'lodash/throttle.js';

//组件中：
methods: {
    changeIndex:throttle(function (index) {
        this.currentIndex = index;
    },50),
}
~~~

### methods中的写法的解析：

* 首先在es5中，对象中写方法都是键值对，键加匿名函数的形式，我们熟悉的在methods中写“具名函数+逗号+具名函数”其实是es6的语法，函数名就是键名
* lodash中的throttle函数返回值是一个函数，说白了throttle是制造节流函数的函数，而本身不是节流函数
* 我们上面用了es5中键值对的方法写methods，键是“changeIndex”，值是用throttle生成的一个匿名函数
* 我测试了一下 工厂函数调用 作为 对象中某个键的值 时，执行的时机（throttle的调用作为methods对象中键changeIndex的值），发现**工厂函数的调用在对象初始化时就会调用，生成的函数作为键的值**，测试代码：

~~~js
function test() {
    console.log("生成函数的函数");
    return function() {
        console.log("生成的函数");
    }
}
let obj = {
    name:test(),
}
//执行这段代码就会输出生成函数的函数，说明对象初始化时工厂函数test就执行了。
~~~

* throttle应该是对它第一个参数的封装，模板中给changeIndex传递的参数其实就是传递给throttle的第一个函数参数了，所以上面的index就是模板中传过来的参数。换句话说 throttle返回的函数 和 传给它的函数 参数结构是一样的。

## 14.三级联动路由跳转

如果选择`router-link`，它的本质就是一个组件，那么在`v-for`生成三级联动的时候，就可能会生成成千上万个`router-link`，也就是成千上万个组件，会占用大量内存，造成卡顿。

所以我们不用声明式导航，选择编程式导航。

然后我们给每一个`<a>`标签都绑定一个点击事件的话，自然性能也不会太好，用**事件委派。即给包裹三级联动的没有进行循环生成的大盒子绑定一个点击监听函数。**但需要解决两个问题：

* 只有点击大盒子里的a标签，我们才进行路由跳转，而不是点击整个大盒子都进行路由跳转。如何判断我们点击的是a标签？确定点击的是a标签之后，又怎么确定是一级a标签还是二级或者三级a标签？
* 路由跳转的时候需要把产品的名字和id传给search组件，如何传参？

我们给一个包含了很多dom元素的大盒子绑定了一个监听事件之后，通过事件的event对象可以获取是哪一个元素被点击了，`event.target`就是被点击的dom元素，比如`<h3 class="fore">...</h3>`这种，然后我们在模板中**给a标签使用自定义属性：**

~~~html
<a :data-categoryName="c1.categoryName">{{c1.categoryName}}</a>
~~~

所谓**自定义属性也就是用v-bind给标签绑定一个":data-"开头的属性**，然后我们如果在js中获得了dom元素，就可以通过dom元素的dataset属性获得一个对象，这个对象里就是所有自定义属性（:data-后面的属性）组成的键值对，我们只需要利用es6的对象解构赋值即可获得dataset里的自定义属性

~~~js
//给外层的大盒子绑定的进行路由转跳的函数
goSearch(event) {
    //通过事件对象的target获得被点击的dom元素
    let element = event.target;
    let {categoryName,category1id,category2id,category3id} = element.dataset;
	//我们只给a标签添加了自定义属性categoryName，先通过有没有categoryName判断点击的是不是a标签
	//然后分别给三级联动的一二三级a标签添加自定义属性category n id，通过这个属性判断是几级的a标签，不同级的a标签传递不同的参数
    if(categoryName) {//如果是a标签
        //开始构造路由转跳的参数
        let location = {name:"search"};
        //构造query参数
        let query = {categoryName: categoryName};
        if(category1id) {
            query.category1id = category1id;
        }else if(category2id) {
            query.category2id = category2id;
        }else {
            query.category3id = category3id;
        }
        location.query = query;
        //路由转跳
        this.$router.push(location);
    }
}
~~~

**自定义属性不管定义时大小写，用`dataset`访问时都转化成了小写，所以上面代码中`let{categoryName,category1id,category2id,category3id} = element.dataset;`应该把categoryName改成categoryname，不然categoryName一直都是undefined。**

## 15.search组件中TypeNav组件的三级联动部分进行显示和隐藏

因为不是整个TypeNav的显示和隐藏，所以显示和隐藏的逻辑不能作用于search中的<TypeNav>,必须把显示和隐藏的逻辑写在<TypeNav>组件的内部，通过`this.$route.path`不同区分search中的TypeNav还是Home中的TypeNav，也就是增加逻辑：当`this.$route.path === "/search"`的时候，进行部分的显示和隐藏。

## 16.search组件中三级联动部分从上往下出现的vue动画效果

transition详细博文：[(38条消息) Vue — transition实现过渡动画_@Demi的博客-CSDN博客_vue的transition过渡动画](https://blog.csdn.net/qq_38128179/article/details/118934676)

### vue动画知识点：

vue动画使用条件：给使用了条件渲染（`v-for`/`v-if`)的dom元素或者组件使用<transition>包含，就可以给它添加动画效果：

自动生成几个动画相关的css类：

* `v-enter-active`:dom元素生成的整个阶段的样式，一般可以设置`transition:transform .5s;`表示生成阶段持续0.5s，生成阶段包含开始状态和结束状态，对应类：
  * `v-enter`
  * `v-enter-to`
* `v-leave-active`:dom元素消失的整个阶段的样式，包含消失的开始状态和结束状态：
  * `v-leave`
  * `v-leave-to`

但是<transition>一旦设置的name属性，那么生成的css类名中将用name值代替v。

### 实现分类列表从上往下出现的效果：

~~~html
<transition name="sort">
	<div class="sort" v-show="show">
        ...
    </div>
</transition>
~~~

~~~css
.sort-enter{
    height: 0px;
}
.sort-enter-to{
    height: 461px;
}
.sort-enter-active{
    transition: all .5s linear;
    //all代表选中sort-enter和sort-enter-to中的所有样式设置过渡效果
}
~~~

## 17.合并路由转跳时同时传递params参数和query参数（需要保留目前已有的参数）

我们由home组件转跳到search组件时，通过搜索框会传递params参数，通过三级联动分类点击会传递query参数，所以我们要考虑如果目前先点击了三级联动，拥有了query参数，这时点击搜索，需要在保留query参数的条件下增加params参数，同样如果先搜索再点击三级联动，也要保留以前的params参数。

构造push的转跳参数location时：

* 保留已有的params参数：

`location.params = this.$route.params;`

* 保留已有的query参数：

`location.query = this.$route.query;`

plus:这里没必要判断是否拥有params参数或者query参数再添加，比如`if(this.$route.params){location.params = this.$route.params;}`,因为`$route`里不管有没有query参数或者params参数，都有query空对象和params空对象，this.$route.params和this.$route.query都是存在的。

## 18.mock（模拟）轮播图数据

1. 首先安装mock依赖：`npm install mockjs`

2. src下建立mock文件夹，里面创立相应的json文件，json文件里面存放json数据，把mock数据需要的图片（json文件中保存图片路径，路径都以“/”开头，因为我们这是在做一个项目，即使后台数据用mock模拟，但也要保证项目打包之后能正常运行，为了能保证json文件中对应的图片能正确访问，我们就要把他放在打包之后仍然能访问的位置）图片放到public文件夹中，（public文件夹在打包的时候，会把相应资源原封不动的放到dist文件夹下）
3. 建立mockServe.js文件，利用mockjs创建相应的ajax请求拦截服务

~~~js
//先引入mockjs模块,Mock是一个对象，身上有一个mock方法，可以创建拦截请求的服务，指定拦截地址和设置返回数据
import Mock from 'mockjs';
//把JSON数据格式引入进来[JSON数据格式根本没有对外暴露，但是可以引入]
//因为webpack默认对外暴露的文件类型：图片、JSON格式数据
import banner from './banner.json';
import floor from './floor.json';

//mock数据:第一个参数是伪造的请求地址，可以向这个地址发请求   第二个参数：想让请求返回的数据
Mock.mock("/mock/banner", { code: 200, data: banner });//模拟首页大的轮播图的数据
Mock.mock("/mock/floor", { code: 200, data: floor });

~~~

4. 在main.js中引入，只是指定执行mockServe.js文件一次即可，main.js:

~~~js
import "@/mock/mockServe.js";
~~~

5. 我们不能用以前封装的axios（给服务器发请求的axios）给mock发请求，因为以前的axios的baseURL是'/api'，现在mock服务的请求baseURL是'/mock'，api文件夹下新建一个"mockRequest.js"，除了baseURL配置其余拷贝'request.js'。

6. 用新建的mockRequest封装的axios在@api/index.js里封装请求函数并暴露即可。

   @api/index.js：

   ~~~js
   ...
   import mockRequest from './mockRequest';
   ...
   export const reqGetBannerList = ()=>mockRequests.get('/banner');
   //mockRequest设置了baseURL为'/mock'，路径拼装起来"/mock/floor"对应Mock.mock函数第一个参数
   ~~~


## 19.利用swiper插件制作ListContainer组件中的轮播图

### 基本swiper使用：

1. 给项目安装5版本swiper：

`npm install swiper@5`

2. 在官网（[Swiper使用方法 - Swiper中文网](https://swiper.com.cn/usage/index.html)）粘贴过来相应的html结构，然后引入用到的css类：

`import "swiper/css/swiper.css"`

​	引入css文件直接import后跟对应的css文件即可，引入位置可以在用到swiper的组件中，但如果项目中多处用到轮播图，也可以在入口文件执行上面的语句（我们的选择）。

3. 引入了结构和样式之后swiper是一个静态的，我们需要创建swiper实例，`import Swiper from 'swiper';    var mySwiper = new Swiper('.swiper',{配置对象});`实例创建之后结构轮播图就是动态的了。需要注意的是**轮播图实例创建必须在html结构存在之后，否则无效，相当于创建swiper实例是对已有的html进行一次激活，如果html不存在，就相当于无效激活。所以就存在一个创建swiper实例的时机的问题。**

### swiper实例化的时机问题：

1. 不可以在组件mounted生命周期中实例化：

mounted是指组件挂载完毕，此时理论上结构已经加载完毕，但有种特殊情况：那就是这里轮播图的结构是遍历bannerList生成的，但bannerList是通过axios异步获取的数据，**mounted时异步数据并没有生成**，所以不能在mounted中实例化swiper。

2. 不在update中实例化：

确实可以激活轮播图，但因为每次组件任何响应式数据更新都重新实例化swiper，浪费资源。

3. 在mounted中用setTimeout包装实例化操作：

可以实现效果，但延时长导致体验差，延时短又容易出bug（这里不是js宏任务微任务的情况，延时短可能setTimeout先于axios）。

### 最优解决方案：watch+nextTick

监听bannerList的变化，但是我们因为**vue的模板渲染机制：在所有代码执行完毕之后才去更新模板，所以即使watch函数中修改了bannerList数据，紧接着实例化swiper的话html中还是没有结构，所以我们要把实例化swiper放在nextTick中**。（nextTick就是指下一次模板更新完毕后执行其回调函数）

~~~js
watch: {
    bannerList(newValue,oldValue) {
        this.$nextTick(()=>{
            var mySwiper = new Swiper(...);
        });
    },
}
~~~

### vue中用ref获取dom结点（new Swiper的第一个参数）：

~~~html
<div ref="mySwiper">
    ...
</div>
~~~

~~~js
var mySwiper = new Swiper(this.$refs.mySwiper,{...});
~~~

## 20.动态展示floor组件数据

没什么新知识点，思路梳理：

1. 写api里请求floor数据的函数

2. 在home组件里发请求，vuex三连环，然后用mapstate获取vuex里的数据（floor组件在home组件里复用两次，请求来的数据是一个数组，里面俩对象分别属于两个不同的floor）

   ~~~html
   <Floor v-for="floor in floorList" :key="floor.id" :list="floor"/>
   ~~~

3. floor组件里props接收传来的数据，然后用这个数据动态渲染html即可。

## 21.提取轮播图为全局组件

因为在ListContainer组件和Floor组件中都存在轮播图，它们的html结构相同，我们可以把它提取出来，然后声明为一个全局组件。我们需要把js部分也统一起来，原本ListContainer中轮播图swiper实例化是在watch+nextTick实现，在Floor中是mounted时实例化swiper，在Carousel（轮播图）组件中我们采用watch+nextTick实现轮播图实例化。然后轮播图播放的图片是遍历的数组决定的，所以我们在其他组件中使用<Carousel>组件时需要传给它一个数组参数，在<Carousel>组件中用props接收使用。

## 22.search模块开发

模块开发思路：

1. 写静态页面+静态组件拆分出来
2. 发请求（API）
3. vuex三连环存储数据+组件中获得vuex中的数据
4. 组件中动态展示数据

## 23.获取search组件的服务器数据

1. api文件夹中定义方法：这里没用`axios.get/post`的方法发请求，而是调用了`axios`方法：

   ~~~js
   export const reqGetSearchInfo = (params) => requests({
       url:"/list",
       method:"post",
       data:params,
   })
   //axios方法的配置对象的data项必须有，起码是个空对象，所以调用reqGetSearchInfo函数时，至少传入一个空对象
   ~~~

2. vuex的search模块中三连环去运用`reqGetSearchInfo`方法:

   ~~~js
   import { reqGetSearchInfo } from "@/api";
   const action = {
       //reqGetSearchInfo至少接收一个空对象，所以用默认参数的写法：params={}
   	async getSearchList({commit},params={}) {
           let result = await reqGetSearchInfo(params);
           if(result.code === 200) {
               commit("GETSEARCHLIST",result.data);
           }
       }
   }
   ~~~

3. （在某个时机）发请求得数据。

## 24.Search组件使用mapGetters获取vuex数据

vuex的store模块中：

~~~js
const getters = {
    //getters中计算属性接收到的state是本模块的state
    goodsList(state) {
        //searchList如果为空对象，goodList就是undefined，不能进行遍历，所以要保证goodsList至少是一个空数组(保证计算属性是一个符合类型要求的变量)
        return state.searchList.goodsList||[];
    },
	...
};
~~~

vuex的所有模块getters属性共享，也就是说不管home模块还是search模块，声明的getters数据在组件中用mapGetters获取的时候直接可以访问到，而不用区分模块

Search组件：

~~~js
computed: {
    //直接可以访问goodsList，同样能直接访问home模块中定义的getters数据
	...mapGetters(['goodsList']),
}
~~~

## 25.配置`dispatch("getSearchList",params)`的params参数：Object.assign合并对象/Search组件根据不同参数发送请求获取数据

1. 配置search组件的data数据：searchParams

   ~~~js
   data() {
     return {
       searchParams: {
         //三级联动点击参数
         category1Id: "",
         category2Id: "",
         category3Id: "",
         categoryName: "",
         //搜索参数
         keyword: "",
         //排序功能相关参数
         order: "",
         //分页器当前页数
         pageNo: 1,
         //每页呈现几个产品
         pageSize: 10,
         //平台售卖属性相关参数（面包屑下面的表格呈现的属性）
         props: [],
         //代表哪个品牌
         trademark: "",
       },
     };
   },
   ~~~

2. 利用$route的query和params参数修改data

   ~~~js
   beforeMount() {
       //Object.assign:把第一个对象往后的对象有的属性给第一个对象，如果属性同名则后面对象的属性值覆盖第一个对象的属性值
   	Object.assign(this.searchParams,this.$route.query,this.$route.params);
   },
   ~~~

   

3. dispatch("getSearchList",this.searchParams);

   ~~~js
   methods: {
       getData() {
           this.$store.dispatch("getSearchList", this.searchParams);
       }
   },
   mounted() {
   	this.getData();
   },
   ~~~

   但是放在mounted中发请求显然是不合适的，因为请求只会在第一次进入search组件时发送一次，后续即使参数更改数据也不会重新发送请求。

## 26.发出Search组件数据请求的时机---->监听$route变化

mounted钩子中只发送第一次请求Search组件数据的请求，需要改进为不管是点击三级联动还是点击搜索，都要根据新的参数重新发送请求获取数据。

解决方案：监视$route，$route本身也是组件的一个数据项，和data中的数据同级，自然可以监视。

~~~js
watch: {
    $route(newValue,oldValue) {
        //检测到$route发生变化，我们要重新发送数据请求，第一件事就是构造请求的参数
     	Object.assign(this.searchParams, this.$route.query, this.$route.params);
        this.getData();
        //因为三级联动的点击参数category1id、category2id、category3id三者每次只能有一个，不能因为这一次请求给this.searchParams添加了其中一个，然后一直携带到以后的请求，所以每次请求完毕后重置categoryId为空
        this.searchParams.category1Id = "";
        this.searchParams.category2Id = "";
        this.searchParams.category3Id = "";
    }
}
~~~

## 27.面包屑的展示与删除

展示：面包屑展示的内容与categoryName绑定，`v-show="categoryName"`即可

删除：点击`×`绑定`removeCategoryName`函数，删除面包屑的逻辑核心就是清除请求的query参数（保留params参数）重新发出没有query参数的请求。

~~~js
removeCategoryName() {
    //1.清除query参数
    this.searchParams.categoryName = undefined;//接口规定为可选参数，设置为undefined就不存在这个参数,可以节省请求时的内存
    this.searchParams.category1id = undefined;
    this.searchParams.category2id = undefined;
    this.searchParams.category3id = undefined;
    //2.更改路由（同时路由更改触发新的请求---无query参数的请求）
    this.$router.push({ name: "search", params: this.$route.params });
}
~~~

keyword相关的面包屑处理与categoryName面包屑类似：在删除keyword面包屑之后清除params参数并重新请求数据，但需要全局事件总线清除Header组件里的搜索框的值。

trademark相关的面包屑：品牌列表是在Search的子组件SearchSelector中v-for遍历trademarkList生成的，我们点击了某个品牌之后，需要把trademark的信息传给父组件（Search组件），因为我们构造的用来请求的数据searchParams在父组件中：子组件传递数据给父组件用自定义事件实现，然后在Search组件中构造请求参数发送请求。和上面点击面包屑和搜索面包屑不同：**trademark信息不是路由参数（他就是search组件内部的行为产生的参数，所以不是路由参数，路由参数是其他组件转到某个路由组件时传递的参数）所以发送请求直接调用`this.getData();`**，而不是`this.$router.push`（其他两种面包屑通过路由转跳可以触发对$route的watch，自动发送请求）。

## 28.bug修改：search组件中categoryId和categoryName全部改为小写

search组件data中categoryId和categoryName的作用就是结合$route的query参数（`Object.assign(this.searchParams, this.$route.query, this.$route.params)`）发出数据请求，因为$route中query参数中是categoryid和categoryname（TypeNav构造向Serach组件转跳的query参数时用的vue自定义数据实现，自定义数据不管标签中是大小写，但通过element.dataset访问时都是小写），所以我们修改Search组件中数据也全为小写。

## 29.平台售卖属性的点击效果

效果：点击平台售卖属性之后，根据选择属性重新发送数据请求，并保存相应的面包屑（可存在多个）

实现思路：SearchSelector组件中，某个属性被点击，整理被点击的属性信息（属性id，属性类型，属性值）通过自定义事件传递给父组件（Search组件）,父组件更新data中的props数组之后重新发送请求，并且遍历props生成面包屑，当面包屑被删除时同样更新props并重新发送请求。

## 30.排序选项的实现

searchParams中的order参数共有四种情况：”1：desc“，”1：asc“，”2：desc“，”2：asc“。1代表综合排序，2代表价格排序；desc代表降序，asc代表升序。

* 根据order中是1还是2动态给html中的选项添加类

  ~~~html
  <li :class="{active:searchParams.order.split(':')[0]==='1'}">
  	<a>综合</a>
  </li>
  ~~~

  或者

  ~~~html
  <li :class="{active:searchParams.order.indexOf('1')!==-1}">
  	<a>综合</a>
  </li>
  ~~~

  可以把`searchParams.order.indexOf('1')!==-1`封装成一个计算属性

  ~~~html
  <li :class="{active: isOne}">
  	<a>综合</a>
  </li>
  ~~~

  ~~~js
  computed:{
  	isOne() {
          return this.searchParams.order.indexOf('1')!==-1;
      }
  }
  ~~~

* 被order选中的（有类的）选项 文字后面有箭头符号：`v-show`

  ~~~html
  <li :class="{active: isTwo}">
      <a>价格<span v-show="isTwo">箭头</span></a>
  </li>
  ~~~

* 用阿里图标库获取箭头图标

  找到图标的在线css样式地址：//at.alicdn.com/t/c/font_3641358_j8roxg2sejt.css，加上https协议在public文件夹下的index.html中引入

  ~~~html
  <link rel="stylesheet" href="https://at.alicdn.com/t/c/font_3641358_j8roxg2sejt.css">
  ~~~

  引入类之后，只要我们给一个盒子元素用上iconfont类以及图标本身对应的类（`<span class="iconfont icon-arrowup"></span>`），这个盒子中就会出现icon-arrowup对应的符号。

  根据order参数是否包含asc或者desc字符决定是上升箭头还是下降箭头（计算属性：`isAsc() {return this.searchParams.order.indexOf("asc") !== -1;},`）

  ~~~html
  <li :class="{active: isOne}">
      <a>综合<span v-show="isOne" class="iconfont" :class="{'icon-arrowup': isAsc,'icon-arrowdown': isDesc}"></span></a>
  </li>
  ~~~

* 给排序选项按钮绑定点击事件，实现：连续点击相同按钮更换升降序，点击不同按钮更换排序方式，默认为降序。

  ~~~js
  changeOrder(flag) {
  	let originFlag = this.searchParams.order.split(":")[0];
      let originSort = this.searchParams.order.split(":")[1];
      //连续点击同一个按钮，flag不变，更换升降序
      if(flag === originFlag) {
          this.searchParams.order = `${flag}:${originSort === "desc" ? "asc" : "desc"}`;
      }else {//点击不同按钮，更换flag
          this.searchParams.order = `${flag}:${originSort}`;
      }
      this.getData();
  }
  ~~~

  

## 31.Pagination--分页器的实现（自定义分页功能）

使用分页器的原因：比如电商平台同时展示的数据量太大，采用分页功能，只渲染展示当前页面的数据。（ElementUI有分页组件，使用简单，但我们不用，以学习分页实现原理）

分页器需要的相关数据：

* 需要知道当前是第几页：`pageNo`
* 需要知道每一页展示多少条数据：`pageSize`
* 需要知道整个分页器一共有多少条数据：`total`
  * 结合上面两点可知道一共多少页`totalPage`
* 需要知道分页器两侧省略号中间有多少个连续页面选项：`continues`，一般是5或者7（奇数），对称、美观。

### 完成分页器的动态展示

所谓分页器的动态展示就是，根据分页器的配置数据，决定一部分html结构的显示和隐藏，具体来说就是分页器的中间部分稳定展示，**用`v-for`遍历数字startNumAndEndNum.end并结合`v-show`隐藏startNumAndEndNum.start之前的数字 生成结构**，分页器前面部分的“1”和“...”、分页器后面的“...”和“totalPage”根据中间部分的起始位置和结束位置适时隐藏掉。

~~~html
<button>上一页</button>
<button v-show="startNumAndEndNum.start>1">1</button>
<button v-show="startNumAndEndNum.start>2">···</button>

<!-- 分页器中间部分 -->
<!-- 中间部分稳定呈现，上部分“1”和“...”和下部分的“...”和“totalPage”根据情况隐藏 -->
<button v-for="(page,index) in startNumAndEndNum.end" :key="index" v-if="page>=startNumAndEndNum.start">{{page}}</button>


<button v-show="startNumAndEndNum.end<totalPage-1">···</button>
<button v-show="startNumAndEndNum.end<totalPage">{{totalPage}}</button>
<button>下一页</button>

<button style="margin-left: 30px">共 {{totalPage}} 条</button>
<div>{{startNumAndEndNum}}</div>
~~~

父组件传递真实分页器数据给`Pagination`组件，并且监听分页器的自定义事件`changePageNo`（得知分页器被点击之后应该切换到哪一页，自定义事件实现子组件给父组件传递信息），给分页器组件中所有可以点击的按钮添加click事件监听，触发自定义事件`changePageNo`并传递应该切换到的页号：`<button :disabled="pageNo===1" @click="$emit('changePageNo',pageNo-1)">上一页</button>`（还得给上一页和下一页动态设置disabled属性）。父组件添加自定义事件`changePageNo`的回调`changePageNo`方法，修改`pageNo`数据并重新发送数据请求。

## 32.Detail组件（点击商品图片时router-link进行跳转）开发--静态组件+配置路由

跳转到Detail组件时携带商品id（params参数）

## 33.路由跳转滚动条行为

实例化VueRouter时添加与routes同级的配置项--scrollBehavior，用来设置转跳到新路由时滚动条的位置。

~~~js
export default new VueRouter({
    routes: [...
    ],
    //跳转到一个新路由时滚动条位置的设置：新路由页面中滚动条在最上面
    scrollBehavior(to, from, savedPosition) {
        // return 期望滚动到哪个的位置
        return { y: 0 };
    }
})
~~~

## 34.一种隐性报错（不影响程序运行）

在vuex中我们向服务器捞商品数据的时候，服务器预期返回的数据goodInfo是一个对象，那么我们就要在state中给goodInfo初始化为一个空对象，然后Detail组件需要goodInfo中的一个对象skuInfo，在getters中创建skuInfo，这时候就不能直接return state.goodInfo.skuInfo，还要或上一个空对象，因为如果不或上空对象，其他组件获得getter中的skuInfo的时候，服务器数据在最开始的时刻可能还没请求到（goodInfo是空对象），goodInfo.skuInfo自然是undefined，其他组件这时候接收到的skuInfo就是一个undefined，自然其他组件如果使用skuInfo，就会报错（TypeError: Cannot read properties of undefined），相当于去访问undefined的某个属性。

然后在Detail组件中，它有一个子组件Zoom（放大镜）,这个组件需要skuInfo对象中的一个数组数据skuImageList，我们在给Zoom传递skuImageList的时候，同理，也需要或上一个空数组，要不然Zoom在使用skuImageList的时候，服务器数据未到达，Zoom中skuImageList是undefind，如果访问undefined的某一项，自然也会报错。

甚至在Zoom中我们只使用skuImageList的第一项的某个属性（skuImageList[0].imgUrl，plus：数组的每一项都是一个对象）,这时候skuImageList[0]可能是undefined，所以我们在Zoom组件内部，都需要一个计算属性imgObj：return skuImageList[0]||{}。

这种bug虽然只是控制台报错（在服务器数据到达之前的很短时间内报错）但不影响程序运行（如果服务器正常的情况下），但原理就是因为数据是在服务器那边获得的，数据在vuex、父组件、子组件中传递时，服务器数据可能没来，父组件获得的vuex中的数据可能是undefined，子组件获得的父组件中的数据可能是undefined，如果使用这些undefined，自然会报错，所以解决方案也很简单，**在vuex中写getters属性时、在父组件中写计算属性（用来传给子组件）时，都根据要传递的这个数据的类型，给它或上一个同类型的空数据即可。**

## 35.数组排他操作实现被选择的商品属性高亮

当有属性值被点击时，高亮属性是我们通过spuSaleAttrValue的isChecked属性为1时动态添加的，我们给回调函数传入spuSaleAttrValueList，所谓排他操作就是把所有spuSaleAttrValue的isCheck都清空为0，然后设置被选中的那一个为目标值（先毁灭全部，再重新设置）