# 项目结构分析

* node_modules文件夹：项目依赖文件夹

* public文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。

* src文件夹（程序员源代码文件夹）：
  * assets文件夹：一般也是放置静态资源（一般放置多个组件公用的静态资源），需要注意，放置在assets文件夹里面静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包JS文件里面
  * components文件夹：一般放置的是非路由组件（全局组件）。
  * App.vue：唯一的根组件
  * main.js：程序的入口文件，也是整个程序当中最先执行的文件

* babel.config.js：配置文件（babel相关，类似于翻译官，比如可以把es6的语法翻译成es5的语法，让兼容性更好）

* package.json文件：类似于项目的“身份证”，记录项目叫什么、项目中有哪些依赖、项目怎么运行等相关信息

* package-lock.json文件：缓存性文件，比如依赖在哪里下载在的等一些过程信息，而且发现依赖第一次下载比较慢，后来比较快，就是因为这个文件有一部分缓存信息。

* READMD.md：说明文件

# 项目的其他配置

## 2.1项目运行起来的时候，让浏览器自动打开

---package.json
    script配置项serve配置最后加--open
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
---node_modules/@vue/cli-service/lib/commands/serve.js
    host的默认值改为'127.0.0.1'
    const defaults = {
    host: '127.0.0.1',
    port: 8080,
    https: false
    }

## 2.2eslint校验功能关闭

  ---在根目录下，创建一个vue.config.js
    设置lintOnSave:false

## 2.3src文件夹简写方法，配置别名。

jsconfig.json配置别名@（@代表src文件夹，这样将来文件过多方便寻找）

## 2.4安装vue-router等依赖时的两种方式：

* 在终端里npm install vue-router，但不知为什么可能是依赖之间不兼容的问题报错
* 在package.json里写好"dependencies"配置项：
      "dependencies": {
          "core-js": "^3.8.3",
          "less": "^4.1.3",
          "less-loader": "^11.0.0",
          "vue": "^2.6.14",
          "vue-router": "^3.5.3"
      },
      然后终端里直接npm install：安装项目的所有依赖，这样可以更明确地指定安装的所有依赖。

# 项目处理技巧

## 1.利用路由元信息控制Footer组件的隐藏与显示

Footer组件：在Home、Search组件显示时显示Footer组件，在登录和注册时隐藏Footer组件。

把Home和Search的元信息（meta项）中的show属性设置为true，登陆组件和注册组件的show属性设置为false

利用v-show结合路由的元信息进行控制：`<Footer v-show="$route.meta.show"><Footer>`

($route就是指**当前路径**对应的**路由组件**的信息，理解：每个路由组件都有对应的path，所以path和路由组件是一一对应的)

## 2.路由知识点复习

### 路由转跳的两种方式：

* 声明式导航：router-link（务必要有to属性），可以实现路由的转跳
* 编程式导航：利用的是组件实例的$router.push|replace方法，可以实现路由的转跳

### 路由传参的两种写法：

* params参数：属于路径当中的一部分(配置路由的时候在path配置项里体现“占位”)，需要注意，在配置路由的时候，需要占位，路由配置的时候：`path:"/home/:keyword",`

* query参数，不属于路径当中的一部分，类似于ajax中的queryString，配置路由的时候不需要占位,传递的时候直接:`/home?k=v&k2=v2`

* 编程式路由导航传递参数的三种写法：

  * 1.字符串形式：`this.$router.push('/search' + this.mydata + "?k=" + this.mydata.toUpperCase());`
  * 2.模板字符串：

  ~~~js
  this.$router.push(`/search/${this.mydata}?k=${this.mydata.toUpperCase}`);
  ~~~
  * 3.对象（但如果有params参数，就必须用组件的name配置，这里的name是路由配置文件中的name，不是组件本身的name，不能用path）

  ~~~js
  this.$router.push({
      name:"search",
      params:{
          mydata,
      },
      query:{
          k:this.mydata.toUpperCase(),
      }
  })
  ~~~

### 路由传参的面试题

1. 路由传递参数（对象写法）path是否可以结合params参数一起使用？（不可以，path必须换成name）
2. 如何指定params参数可传可不传？

情景：配置路由的时候，写了params参数的占位，但是路由跳转的时候不传递，那么路径就会出现问题，我们需要在占位的后面加一个“？”表示这个params参数可以传也可以不传。

3. 当某个params参数可传可不传时，我们给这个params参数传递了一个空字符串，这时候就会出现bug，路径又会出现问题，我们只需令空字符串或上undefined即可解决

~~~js
this.$router.push({
    name:"search",
    params:{
        mydata:""||undefined,
    },
    query:{
        k:this.mydata.toUpperCase(),
    }
})
~~~

4. 路由组件利用props传递数据？

* 路由配置文件中：`props:true`,就是说这个路由组件就收到的params参数可以用props接收
* `props:{a:1,b:2}`就是说额外传递一个a和b，然后路由组件中可以用props接收到a和b
* `props:()=>{return {keyword:$route.params.keyword,k:$route.query.k};}`然后路由组件中就可以用props接收到keyword和k，这种函数写法相返回什么都可以，对应路由组件中就接收什么。

## 3.编程式路由导航（由home到search时）重复多次点击转跳会导致NavigationDuplicated的错误警告

声明式路由导航没有这个问题，因为vue-router底层已经处理好了；但编程式路由导航会出现这个问题，因为"vue-router": "^3.5.3"引入了promise，导致`$router.push`返回一个promise对象，所以其实`$router.push`需要接收三个参数，除了第一个参数为指定路径和参数的字符串之外，还需要接收promise的成功回调和失败回调，底层出现这个bug的原理就是因为没有指定成功与失败的回调，导致一直进入现在已经在的路径无法处理。所以我们可以在调用`$router.push`时传入成功与失败的回调函数，或者**对$router的`push`和`replace`方法进行重写（封装）**，让push方法可以只接收第一个参数而不报错。

路由配置文件中：

~~~js
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);

//先把VueRouter原型对象的push方法的函数体保存一份
let originPush = VueRouter.prototype.push;

//重写push|replace
//参数结构与原来的push保持一致，第一个表示跳转的目标位置，后面俩为回调
VueRouter.prototype.push = function(location,resolve,reject) {
    if(resolve && reject) {
        originPush.call(this,location,resolve,reject);
    }else {
        originPush.call(this,location,()=>{},()=>{});
    }
}
~~~

### 重写push方法的注意点：

* 在组件js中利用$router去使用push其实就是访问Vuerouter原型对象上的push方法（Vuerouter是我们引入的路由器构造函数，$router其实就是一个Vuerouter的实例），我们通过originPush保存了原来push方法的函数体，但这个originPush不属于任何对象了（理解可看”前端面试-this“），在调用originPush时直接属于window，所以在重写的函数体中需要用`call`方法让push的this为Vuerouter的原型对象，才能达到路由跳转的功能，因为直接调用originPush的话，this是window，里面的逻辑肯定不对。



## 4.三级联动组件的拆分思路

因为在Search、Home等多个组件中都在使用，所以我们把它注册为全局组件。（好处：只需注册一次，项目的任意位置使用）

在入口文件（main.js中）引入全局组件

~~~js
//三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav';
//Vue.component注册全局组件，第一个参数指定想要注册的名字，第二个参数指定组件的信息
//因为我们在Home组件下，已经写了TypeNav组件，所以我们这在里注册全局组件只需要用Home下的TypeNav即可，所以要注册的全局组件的名字就是TypeNav.name，组件内容就是TypeNav
Vue.component(TypeNav.name,TypeNav);
~~~

## 5.axios二次封装

### axios二次封装的意义：

利用请求拦截器和响应拦截器：

* 请求拦截器：发请求之前处理一些业务
* 响应拦截器：服务器数据返回以后处理一些业务

### 文件位置：

项目当中src文件夹下有一个api文件夹，里面存放关于axios的相关文件

### @/api/request.js:

~~~js
//对于axios进行二次封装
import axios from "axios";

//1.利用axios对象的方法create创建一个axios实例，而且我们create一个axios实例的时候可以进行配置
const requests = axios.create({
    //给服务器地址增加上默认路径api
    baseURL:"/api",
    //请求超过5s就默认失败
    timeout:5000
})

//请求拦截器
requests.interceptors.request.use((config)=>{
    //config:配置对象，对象里面有一个属性很重要：headers--请求头
    return config;
});

//响应拦截器
requests.interceptors.response.use((res)=>{
    //成功的回调函数，接收服务器发来的响应数据
    return res.data;
},(error)=>{
    //失败的回调函数
    //终结promise链
    return Promise.reject(new Error('faile'));
});

//暴露出处理好的axios实例对象requests
export default requests;
~~~

## 6.项目接口统一管理

如果项目很小，完全可以在组件的生命周期中发请求，得到数据之后存放在data中，但如果项目很大，成千上百个组件中都写了`axios.get('xxx')`接口一旦改变，每一个请求都得改过来，所以需要接口统一管理，我们只需在统一管理的位置改一下就完成了所有组件的接口地址更改。

在api文件夹下，创建文件index.js，然后里面封装一些向对应接口发请求的方法，并且暴露这些方法，然后组件中需要发请求的时候引入方法使用即可。

比如封装请求三级联动导航数据的方法：

~~~js
//@/api/index.js:
//引入封装好的axios--->requests
import requests from "./request";
//箭头函数，函数体发送就是用axios发送请求
export const reqCategoryList = () => requests({
    url:'/product/getBaseCategoryList',
    method:'get',
})

//但这样发请求默认是向咱们前端项目本身的ip地址发送请求，我们要请求远程服务器，但要解决跨域问题：
//webpack为我们提供了“代理服务器”解决跨域问题
//在webpack.config.js中进行配置，这个文件就相当于我们vue项目中的vue.config.js
//vue.config.js中添加“代理”配置
devServer: {
    proxy: {
        //api代表如果前端发送的请求路径中如果有api，那么就把这个请求发送给target对应的服务器（相当于webpack提供的服务器对真正的服务器进行代理）
        '/api': {
            target:'http://gmall-h5-api.atguigu.cn'
        }
    }
}
~~~

## 7.请求进度条效果

1. 安装nprogress：`npm install nprogress`
2. 在请求拦截器和响应拦截器中设置进度条开始和进度条结束：

`@/api/request.js:`

~~~js
//引入进度条
import nprogress from 'nprogress';
//引入进度条样式
import 'nprogress/nprogress.css';
//nprogress是一个对象，里面有start方法和done方法，调用使进度条开始和结束，在请求拦截器中start、请求响应拦截器中done即可完成进度条效果
requests.interceptors.request.use((config)=>{
    nprogress.start();
    return config;
});
requests.interceptors.response.use((res)=>{
    nprogress.done();
    return res.data;
},(error)=>{
    return Promise.reject(new Error("faile"));
})
~~~

## 8.安装vuex

~~~js
npm install vuex@3.6.2
~~~

`@/store/index.js:`

~~~js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const state = {};
const mutations = {};
const actions = {};
const getters = {};

export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters,
})
~~~

`main.js:`

~~~js
...
import store from '@/store';
new Vue({
    ...
    //注册仓库，组件实例身上会多一个$store属性
    store,
    ...
})
~~~

### 用vuex的模块化开发：

`@/store/search/index.js:`

~~~js
//search模块的小仓库
const state = {};
const mutations = {};
const actions = {};
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters,
}
~~~

`@/store/index.js:`

~~~js
...
//引入小仓库
import search from './search';

exprot default new Vuex.Store({
	modules: {
        search,
        ...
    }
})
~~~

## 9.动态展示三级联动数据

​	三级联动数据的展示是在页面加载完成时就要呈现给用户的，所以我们选择在TypeNav组件挂载完毕之后（某个生命周期，也可以是created）就去请求数据，给vuex发送请求之后，在vuex中先引入api（接口统一管理文件夹）中定义的请求函数，再在actions中调用获取数据，然后再mutations中修改state中的数据，这里牵扯一个state中数据初始化的问题，我们要看接口返回什么数据，接口返回数组就初始化为数组，返回对象就初始化为一个对象。

​	获取数据之后，就是运用数据去渲染页面了，找准同级结构，然后留下一个结构用v-for遍历数据生成所有同级数据即可。

### 有关请求结构的思考：

我们在vuex的actions中发请求的时候，用的是现成的函数，这个函数在api文件夹中定义，函数体就是用requests（封装的axios）发送一个请求，发请求时用配置对象指定url和method，url不用写全路径，因为这里的url是建立在requests和vue.config.js基础之上的：

* 封装axios生成requests的时候，配置了`baseURL:"/api"`，所以我们发送请求的地址都自动加上/api
* vue.config.js中配置了请求代理服务器：

~~~js
devServer: {
        proxy: {
            '/api': {
                target: 'http://gmall-h5-api.atguigu.cn'
            }
        }
    }
~~~

也就是说，如果我们发送的请求是/api开头，那么默认这个请求是发给target指定的服务器的

所以说，我们在api中定义的请求函数url只写`'/product/getBaseCategoryList'`就相当于先加上了baseURL，然后又因为有了api，所以默认是发给`'http://gmall-h5-api.atguigu.cn'`的请求，最终请求函数相当于用axios给`'http://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList'`发出了请求。

## 10.三级联动动态添加背景颜色

### css方案：

给同一级的结构添加`:hover`样式，设置background-color为某种颜色

### js方案：

对同一级的结构进行编号，用一个`currentIndex`保存鼠标放在了哪一个结构上，然后在标签中给`index===currentIndex`的结构加上样式。

#### vue给标签动态添加样式语法：

`<p :class="{'stylename': true/false}"`

## 11.事件委派处理效果：上方鼠标进入“全部商品分类”但保留相邻元素的背景颜色不消失

如果我们给三级联动中第一级的每一项都添加鼠标离开的监听事件，不光效率低，而且没法做到鼠标进入“全部商品分类”而且保留相邻元素的背景颜色不消失的效果，这时候，我们把“全部商品分类”和三级联动第一级用一个div包裹起来，然后给这个div添加鼠标离开的监听事件，相当于原本属于每一个小盒子和“全部商品分类”的鼠标离开事件委派给了外层的div。（事件委派的生动理解：公司三个员工去公司门口等快递或者把收快递这件事委派给公司前台人员一个人）

## 12.js控制二三级联动导航的显示和隐藏

在以前`display:none`且`:hover`时`display:block`的盒子上用vue动态添加样式：`:style="{display:currentIndex===index?'block':'none'}"`

