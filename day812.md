# 项目结构分析

* node_modules文件夹：项目依赖文件夹

* public文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。

* src文件夹（程序员源代码文件夹）：
  * assets文件夹：一般也是放置静态资源（一般放置多个组件公用的静态资源），需要注意，放置在assets文件夹里面静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包JS文件里面
  * components文件夹：一般放置的是非路由组件（全局组件）。
  * App.vue：唯一的根组件
  * main.js：程序的入口文件，也是整个程序当中最先执行的文件

* babel.config.js：配置文件（babel相关，类似于翻译官，比如可以把es6的语法翻译成es5的语法，让兼容性更好）

* package.json文件：类似于项目的“身份证”，记录项目叫什么、项目中有哪些依赖、项目怎么运行等相关信息

* package-lock.json文件：缓存性文件，比如依赖在哪里下载在的等一些过程信息，而且发现依赖第一次下载比较慢，后来比较快，就是因为这个文件有一部分缓存信息。

* READMD.md：说明文件

# 项目的其他配置

## 2.1项目运行起来的时候，让浏览器自动打开

---package.json
    script配置项serve配置最后加--open
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
---node_modules/@vue/cli-service/lib/commands/serve.js
    host的默认值改为'127.0.0.1'
    const defaults = {
    host: '127.0.0.1',
    port: 8080,
    https: false
    }

## 2.2eslint校验功能关闭

  ---在根目录下，创建一个vue.config.js
    设置lintOnSave:false

## 2.3src文件夹简写方法，配置别名。

jsconfig.json配置别名@（@代表src文件夹，这样将来文件过多方便寻找）

## 2.4安装vue-router等依赖时的两种方式：

* 在终端里npm install vue-router，但不知为什么可能是依赖之间不兼容的问题报错
* 在package.json里写好"dependencies"配置项：
      "dependencies": {
          "core-js": "^3.8.3",
          "less": "^4.1.3",
          "less-loader": "^11.0.0",
          "vue": "^2.6.14",
          "vue-router": "^3.5.3"
      },
      然后终端里直接npm install：安装项目的所有依赖，这样可以更明确地指定安装的所有依赖。

# 项目处理技巧

## 1.利用路由元信息控制Footer组件的隐藏与显示

Footer组件：在Home、Search组件显示时显示Footer组件，在登录和注册时隐藏Footer组件。

把Home和Search的元信息（meta项）中的show属性设置为true，登陆组件和注册组件的show属性设置为false

利用v-show结合路由的元信息进行控制：`<Footer v-show="$route.meta.show"><Footer>`

($route就是指**当前路径**对应的**路由组件**的信息，理解：每个路由组件都有对应的path，所以path和路由组件是一一对应的)

## 2.路由知识点复习

### 路由转跳的两种方式：

* 声明式导航：router-link（务必要有to属性），可以实现路由的转跳
* 编程式导航：利用的是组件实例的$router.push|replace方法，可以实现路由的转跳

### 路由传参的两种写法：

* params参数：属于路径当中的一部分(配置路由的时候在path配置项里体现“占位”)，需要注意，在配置路由的时候，需要占位，路由配置的时候：`path:"/home/:keyword",`

* query参数，不属于路径当中的一部分，类似于ajax中的queryString，配置路由的时候不需要占位,传递的时候直接:`/home?k=v&k2=v2`

* 编程式路由导航传递参数的三种写法：

  * 1.字符串形式：`this.$router.push('/search' + this.mydata + "?k=" + this.mydata.toUpperCase());`
  * 2.模板字符串：

  ~~~js
  this.$router.push(`/search/${this.mydata}?k=${this.mydata.toUpperCase}`);
  ~~~
  * 3.对象（但如果有params参数，就必须用组件的name配置，这里的name是路由配置文件中的name，不是组件本身的name，不能用path）

  ~~~js
  this.$router.push({
      name:"search",
      params:{
          mydata,
      },
      query:{
          k:this.mydata.toUpperCase(),
      }
  })
  ~~~

### 路由传参的面试题

1. 路由传递参数（对象写法）path是否可以结合params参数一起使用？（不可以，path必须换成name）
2. 如何指定params参数可传可不传？

情景：配置路由的时候，写了params参数的占位，但是路由跳转的时候不传递，那么路径就会出现问题，我们需要在占位的后面加一个“？”表示这个params参数可以传也可以不传。

3. 当某个params参数可传可不传时，我们给这个params参数传递了一个空字符串，这时候就会出现bug，路径又会出现问题，我们只需令空字符串或上undefined即可解决

~~~js
this.$router.push({
    name:"search",
    params:{
        mydata:""||undefined,
    },
    query:{
        k:this.mydata.toUpperCase(),
    }
})
~~~

4. 路由组件利用props传递数据？

* 路由配置文件中：`props:true`,就是说这个路由组件就收到的params参数可以用props接收
* `props:{a:1,b:2}`就是说额外传递一个a和b，然后路由组件中可以用props接收到a和b
* `props:()=>{return {keyword:$route.params.keyword,k:$route.query.k};}`然后路由组件中就可以用props接收到keyword和k，这种函数写法相返回什么都可以，对应路由组件中就接收什么。

## 3.编程式路由导航（由home到search时）重复多次点击转跳会导致NavigationDuplicated的错误警告

声明式路由导航没有这个问题，因为vue-router底层已经处理好了；但编程式路由导航会出现这个问题，因为"vue-router": "^3.5.3"引入了promise，导致`$router.push`返回一个promise对象，所以其实`$router.push`需要接收三个参数，除了第一个参数为指定路径和参数的字符串之外，还需要接收promise的成功回调和失败回调，底层出现这个bug的原理就是因为没有指定成功与失败的回调，导致一直进入现在已经在的路径无法处理。所以我们可以在调用`$router.push`时传入成功与失败的回调函数，或者**对$router的`push`和`replace`方法进行重写（封装）**，让push方法可以只接收第一个参数而不报错。

路由配置文件中：

~~~js
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);

//先把VueRouter原型对象的push方法的函数体保存一份
let originPush = VueRouter.prototype.push;

//重写push|replace
//参数结构与原来的push保持一致，第一个表示跳转的目标位置，后面俩为回调
VueRouter.prototype.push = function(location,resolve,reject) {
    if(resolve && reject) {
        originPush.call(this,location,resolve,reject);
    }else {
        originPush.call(this,location,()=>{},()=>{});
    }
}
~~~

### 重写push方法的注意点：

* 在组件js中利用$router去使用push其实就是访问Vuerouter原型对象上的push方法（Vuerouter是我们引入的路由器构造函数，$router其实就是一个Vuerouter的实例），我们通过originPush保存了原来push方法的函数体，但这个originPush不属于任何对象了（理解可看”前端面试-this“），在调用originPush时直接属于window，所以在重写的函数体中需要用`call`方法让push的this为Vuerouter的原型对象，才能达到路由跳转的功能，因为直接调用originPush的话，this是window，里面的逻辑肯定不对。