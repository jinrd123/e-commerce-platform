# 项目结构分析

* node_modules文件夹：项目依赖文件夹

* public文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。

* src文件夹（程序员源代码文件夹）：
  * assets文件夹：一般也是放置静态资源（一般放置多个组件公用的静态资源），需要注意，放置在assets文件夹里面静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包JS文件里面
  * components文件夹：一般放置的是非路由组件（全局组件）。
  * App.vue：唯一的根组件
  * main.js：程序的入口文件，也是整个程序当中最先执行的文件

* babel.config.js：配置文件（babel相关，类似于翻译官，比如可以把es6的语法翻译成es5的语法，让兼容性更好）

* package.json文件：类似于项目的“身份证”，记录项目叫什么、项目中有哪些依赖、项目怎么运行等相关信息

* package-lock.json文件：缓存性文件，比如依赖在哪里下载在的等一些过程信息，而且发现依赖第一次下载比较慢，后来比较快，就是因为这个文件有一部分缓存信息。

* READMD.md：说明文件

# 项目的其他配置

## 2.1项目运行起来的时候，让浏览器自动打开

---package.json
    script配置项serve配置最后加--open
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
---node_modules/@vue/cli-service/lib/commands/serve.js
    host的默认值改为'127.0.0.1'
    const defaults = {
    host: '127.0.0.1',
    port: 8080,
    https: false
    }

## 2.2eslint校验功能关闭

  ---在根目录下，创建一个vue.config.js
    设置lintOnSave:false

## 2.3src文件夹简写方法，配置别名。

jsconfig.json配置别名@（@代表src文件夹，这样将来文件过多方便寻找）

## 2.4安装vue-router等依赖时的两种方式：

* 在终端里npm install vue-router，但不知为什么可能是依赖之间不兼容的问题报错
* 在package.json里写好"dependencies"配置项：
      "dependencies": {
          "core-js": "^3.8.3",
          "less": "^4.1.3",
          "less-loader": "^11.0.0",
          "vue": "^2.6.14",
          "vue-router": "^3.5.3"
      },
      然后终端里直接npm install：安装项目的所有依赖，这样可以更明确地指定安装的所有依赖。

# 项目处理技巧

## 1.利用路由元信息控制Footer组件的隐藏与显示

Footer组件：在Home、Search组件显示时显示Footer组件，在登录和注册时隐藏Footer组件。

把Home和Search的元信息（meta项）中的show属性设置为true，登陆组件和注册组件的show属性设置为false

利用v-show结合路由的元信息进行控制：`<Footer v-show="$route.meta.show"><Footer>`

($route就是指**当前路径**对应的**路由组件**的信息，理解：每个路由组件都有对应的path，所以path和路由组件是一一对应的)

## 2.路由知识点复习

### 路由转跳的两种方式：

* 声明式导航：router-link（务必要有to属性），可以实现路由的转跳
* 编程式导航：利用的是组件实例的$router.push|replace方法，可以实现路由的转跳

### 路由传参的两种写法：

* params参数：属于路径当中的一部分(配置路由的时候在path配置项里体现“占位”)，需要注意，在配置路由的时候，需要占位，路由配置的时候：`path:"/home/:keyword",`

* query参数，不属于路径当中的一部分，类似于ajax中的queryString，配置路由的时候不需要占位,传递的时候直接:`/home?k=v&k2=v2`

* 编程式路由导航传递参数的三种写法：

  * 1.字符串形式：`this.$router.push('/search' + this.mydata + "?k=" + this.mydata.toUpperCase());`
  * 2.模板字符串：

  ~~~js
  this.$router.push(`/search/${this.mydata}?k=${this.mydata.toUpperCase}`);
  ~~~
  * 3.对象（但如果有params参数，就必须用组件的name配置，这里的name是路由配置文件中的name，不是组件本身的name，不能用path）

  ~~~js
  this.$router.push({
      name:"search",
      params:{
          mydata,
      },
      query:{
          k:this.mydata.toUpperCase(),
      }
  })
  ~~~

### 路由传参的面试题

1. 路由传递参数（对象写法）path是否可以结合params参数一起使用？（不可以，path必须换成name）
2. 如何指定params参数可传可不传？

情景：配置路由的时候，写了params参数的占位，但是路由跳转的时候不传递，那么路径就会出现问题，我们需要在占位的后面加一个“？”表示这个params参数可以传也可以不传。

3. 当某个params参数可传可不传时，我们给这个params参数传递了一个空字符串，这时候就会出现bug，路径又会出现问题，我们只需令空字符串或上undefined即可解决

~~~js
this.$router.push({
    name:"search",
    params:{
        mydata:""||undefined,
    },
    query:{
        k:this.mydata.toUpperCase(),
    }
})
~~~

4. 路由组件利用props传递数据？

* 路由配置文件中：`props:true`,就是说这个路由组件就收到的params参数可以用props接收
* `props:{a:1,b:2}`就是说额外传递一个a和b，然后路由组件中可以用props接收到a和b
* `props:()=>{return {keyword:$route.params.keyword,k:$route.query.k};}`然后路由组件中就可以用props接收到keyword和k，这种函数写法相返回什么都可以，对应路由组件中就接收什么。

## 3.编程式路由导航（由home到search时）重复多次点击转跳会导致NavigationDuplicated的错误警告

声明式路由导航没有这个问题，因为vue-router底层已经处理好了；但编程式路由导航会出现这个问题，因为"vue-router": "^3.5.3"引入了promise，导致`$router.push`返回一个promise对象，所以其实`$router.push`需要接收三个参数，除了第一个参数为指定路径和参数的字符串之外，还需要接收promise的成功回调和失败回调，底层出现这个bug的原理就是因为没有指定成功与失败的回调，导致一直进入现在已经在的路径无法处理。所以我们可以在调用`$router.push`时传入成功与失败的回调函数，或者**对$router的`push`和`replace`方法进行重写（封装）**，让push方法可以只接收第一个参数而不报错。

路由配置文件中：

~~~js
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);

//先把VueRouter原型对象的push方法的函数体保存一份
let originPush = VueRouter.prototype.push;

//重写push|replace
//参数结构与原来的push保持一致，第一个表示跳转的目标位置，后面俩为回调
VueRouter.prototype.push = function(location,resolve,reject) {
    if(resolve && reject) {
        originPush.call(this,location,resolve,reject);
    }else {
        originPush.call(this,location,()=>{},()=>{});
    }
}
~~~

### 重写push方法的注意点：

* 在组件js中利用$router去使用push其实就是访问Vuerouter原型对象上的push方法（Vuerouter是我们引入的路由器构造函数，$router其实就是一个Vuerouter的实例），我们通过originPush保存了原来push方法的函数体，但这个originPush不属于任何对象了（理解可看”前端面试-this“），在调用originPush时直接属于window，所以在重写的函数体中需要用`call`方法让push的this为Vuerouter的原型对象，才能达到路由跳转的功能，因为直接调用originPush的话，this是window，里面的逻辑肯定不对。



## 4.三级联动组件的拆分思路

因为在Search、Home等多个组件中都在使用，所以我们把它注册为全局组件。（好处：只需注册一次，项目的任意位置使用）

在入口文件（main.js中）引入全局组件

~~~js
//三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav';
//Vue.component注册全局组件，第一个参数指定想要注册的名字，第二个参数指定组件的信息
//因为我们在Home组件下，已经写了TypeNav组件，所以我们这在里注册全局组件只需要用Home下的TypeNav即可，所以要注册的全局组件的名字就是TypeNav.name，组件内容就是TypeNav
Vue.component(TypeNav.name,TypeNav);
~~~

## 5.axios二次封装

### axios二次封装的意义：

利用请求拦截器和响应拦截器：

* 请求拦截器：发请求之前处理一些业务
* 响应拦截器：服务器数据返回以后处理一些业务

### 文件位置：

项目当中src文件夹下有一个api文件夹，里面存放关于axios的相关文件

### @/api/request.js:

~~~js
//对于axios进行二次封装
import axios from "axios";

//1.利用axios对象的方法create创建一个axios实例，而且我们create一个axios实例的时候可以进行配置
const requests = axios.create({
    //给服务器地址增加上默认路径api
    baseURL:"/api",
    //请求超过5s就默认失败
    timeout:5000
})

//请求拦截器
requests.interceptors.request.use((config)=>{
    //config:配置对象，对象里面有一个属性很重要：headers--请求头
    return config;
});

//响应拦截器
requests.interceptors.response.use((res)=>{
    //成功的回调函数，接收服务器发来的响应数据
    return res.data;
},(error)=>{
    //失败的回调函数
    //终结promise链
    return Promise.reject(new Error('faile'));
});

//暴露出处理好的axios实例对象requests
export default requests;
~~~

## 6.项目接口统一管理

如果项目很小，完全可以在组件的生命周期中发请求，得到数据之后存放在data中，但如果项目很大，成千上百个组件中都写了`axios.get('xxx')`接口一旦改变，每一个请求都得改过来，所以需要接口统一管理，我们只需在统一管理的位置改一下就完成了所有组件的接口地址更改。

在api文件夹下，创建文件index.js，然后里面封装一些向对应接口发请求的方法，并且暴露这些方法，然后组件中需要发请求的时候引入方法使用即可。

比如封装请求三级联动导航数据的方法：

~~~js
//@/api/index.js:
//引入封装好的axios--->requests
import requests from "./request";
//箭头函数，函数体发送就是用axios发送请求
export const reqCategoryList = () => requests({
    url:'/product/getBaseCategoryList',
    method:'get',
})

//但这样发请求默认是向咱们前端项目本身的ip地址发送请求，我们要请求远程服务器，但要解决跨域问题：
//webpack为我们提供了“代理服务器”解决跨域问题
//在webpack.config.js中进行配置，这个文件就相当于我们vue项目中的vue.config.js
//vue.config.js中添加“代理”配置
devServer: {
    proxy: {
        //api代表如果前端发送的请求路径中如果有api，那么就把这个请求发送给target对应的服务器（相当于webpack提供的服务器对真正的服务器进行代理）
        '/api': {
            target:'http://gmall-h5-api.atguigu.cn'
        }
    }
}
~~~

## 7.请求进度条效果

1. 安装nprogress：`npm install nprogress`
2. 在请求拦截器和响应拦截器中设置进度条开始和进度条结束：

`@/api/request.js:`

~~~js
//引入进度条
import nprogress from 'nprogress';
//引入进度条样式
import 'nprogress/nprogress.css';
//nprogress是一个对象，里面有start方法和done方法，调用使进度条开始和结束，在请求拦截器中start、请求响应拦截器中done即可完成进度条效果
requests.interceptors.request.use((config)=>{
    nprogress.start();
    return config;
});
requests.interceptors.response.use((res)=>{
    nprogress.done();
    return res.data;
},(error)=>{
    return Promise.reject(new Error("faile"));
})
~~~

## 8.安装vuex

~~~js
npm install vuex@3.6.2
~~~

`@/store/index.js:`

~~~js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const state = {};
const mutations = {};
const actions = {};
const getters = {};

export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters,
})
~~~

`main.js:`

~~~js
...
import store from '@/store';
new Vue({
    ...
    //注册仓库，组件实例身上会多一个$store属性
    store,
    ...
})
~~~

### 用vuex的模块化开发：

`@/store/search/index.js:`

~~~js
//search模块的小仓库
const state = {};
const mutations = {};
const actions = {};
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters,
}
~~~

`@/store/index.js:`

~~~js
...
//引入小仓库
import search from './search';

exprot default new Vuex.Store({
	modules: {
        search,
        ...
    }
})
~~~

## 9.动态展示三级联动数据

​	三级联动数据的展示是在页面加载完成时就要呈现给用户的，所以我们选择在TypeNav组件挂载完毕之后（某个生命周期，也可以是created）就去请求数据，给vuex发送请求之后，在vuex中先引入api（接口统一管理文件夹）中定义的请求函数，再在actions中调用获取数据，然后再mutations中修改state中的数据，这里牵扯一个state中数据初始化的问题，我们要看接口返回什么数据，接口返回数组就初始化为数组，返回对象就初始化为一个对象。

​	获取数据之后，就是运用数据去渲染页面了，找准同级结构，然后留下一个结构用v-for遍历数据生成所有同级数据即可。

### 有关请求结构的思考：

我们在vuex的actions中发请求的时候，用的是现成的函数，这个函数在api文件夹中定义，函数体就是用requests（封装的axios）发送一个请求，发请求时用配置对象指定url和method，url不用写全路径，因为这里的url是建立在requests和vue.config.js基础之上的：

* 封装axios生成requests的时候，配置了`baseURL:"/api"`，所以我们发送请求的地址都自动加上/api
* vue.config.js中配置了请求代理服务器：

~~~js
devServer: {
        proxy: {
            '/api': {
                target: 'http://gmall-h5-api.atguigu.cn'
            }
        }
    }
~~~

也就是说，如果我们发送的请求是/api开头，那么默认这个请求是发给target指定的服务器的

所以说，我们在api中定义的请求函数url只写`'/product/getBaseCategoryList'`就相当于先加上了baseURL，然后又因为有了api，所以默认是发给`'http://gmall-h5-api.atguigu.cn'`的请求，最终请求函数相当于用axios给`'http://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList'`发出了请求。

## 10.三级联动动态添加背景颜色

### css方案：

给同一级的结构添加`:hover`样式，设置background-color为某种颜色

### js方案：

对同一级的结构进行编号，用一个`currentIndex`保存鼠标放在了哪一个结构上，然后在标签中给`index===currentIndex`的结构加上样式。

#### vue给标签动态添加样式语法：

`<p :class="{'stylename': true/false}"`

## 11.事件委派处理效果：上方鼠标进入“全部商品分类”但保留相邻元素的背景颜色不消失

如果我们给三级联动中第一级的每一项都添加鼠标离开的监听事件，不光效率低，而且没法做到鼠标进入“全部商品分类”而且保留相邻元素的背景颜色不消失的效果，这时候，我们把“全部商品分类”和三级联动第一级用一个div包裹起来，然后给这个div添加鼠标离开的监听事件，相当于原本属于每一个小盒子和“全部商品分类”的鼠标离开事件委派给了外层的div。（事件委派的生动理解：公司三个员工去公司门口等快递或者把收快递这件事委派给公司前台人员一个人）

## 12.js控制二三级联动导航的显示和隐藏

在以前`display:none`且`:hover`时`display:block`的盒子上用vue动态添加样式：`:style="{display:currentIndex===index?'block':'none'}"`

## 13.三级联动设置节流

利用lodash，lodash里面有各种各样的函数，lodash里的`throttle`就是封装的节流函数，直接引入使用即可。

~~~js
/*引入lodash的全部函数
import _ from "lodash";*/
//按需引入lodash中的节流函数
import throttle from 'lodash/throttle.js';

//组件中：
methods: {
    changeIndex:throttle(function (index) {
        this.currentIndex = index;
    },50),
}
~~~

### methods中的写法的解析：

* 首先在es5中，对象中写方法都是键值对，键加匿名函数的形式，我们熟悉的在methods中写“具名函数+逗号+具名函数”其实是es6的语法，函数名就是键名
* lodash中的throttle函数返回值是一个函数，说白了throttle是制造节流函数的函数，而本身不是节流函数
* 我们上面用了es5中键值对的方法写methods，键是“changeIndex”，值是用throttle生成的一个匿名函数
* 我测试了一下 工厂函数调用 作为 对象中某个键的值 时，执行的时机（throttle的调用作为methods对象中键changeIndex的值），发现**工厂函数的调用在对象初始化时就会调用，生成的函数作为键的值**，测试代码：

~~~js
function test() {
    console.log("生成函数的函数");
    return function() {
        console.log("生成的函数");
    }
}
let obj = {
    name:test(),
}
//执行这段代码就会输出生成函数的函数，说明对象初始化时工厂函数test就执行了。
~~~

* throttle应该是对它第一个参数的封装，模板中给changeIndex传递的参数其实就是传递给throttle的第一个函数参数了，所以上面的index就是模板中传过来的参数。换句话说 throttle返回的函数 和 传给它的函数 参数结构是一样的。

## 14.三级联动路由跳转

如果选择`router-link`，它的本质就是一个组件，那么在`v-for`生成三级联动的时候，就可能会生成成千上万个`router-link`，也就是成千上万个组件，会占用大量内存，造成卡顿。

所以我们不用声明式导航，选择编程式导航。

然后我们给每一个`<a>`标签都绑定一个点击事件的话，自然性能也不会太好，用**事件委派。即给包裹三级联动的没有进行循环生成的大盒子绑定一个点击监听函数。**但需要解决两个问题：

* 只有点击大盒子里的a标签，我们才进行路由跳转，而不是点击整个大盒子都进行路由跳转。如何判断我们点击的是a标签？确定点击的是a标签之后，又怎么确定是一级a标签还是二级或者三级a标签？
* 路由跳转的时候需要把产品的名字和id传给search组件，如何传参？

我们给一个包含了很多dom元素的大盒子绑定了一个监听事件之后，通过事件的event对象可以获取是哪一个元素被点击了，`event.target`就是被点击的dom元素，比如`<h3 class="fore">...</h3>`这种，然后我们在模板中**给a标签使用自定义属性：**

~~~html
<a :data-categoryName="c1.categoryName">{{c1.categoryName}}</a>
~~~

所谓**自定义属性也就是用v-bind给标签绑定一个":data-"开头的属性**，然后我们如果在js中获得了dom元素，就可以通过dom元素的dataset属性获得一个对象，这个对象里就是所有自定义属性（:data-后面的属性）组成的键值对，我们只需要利用es6的对象解构赋值即可获得dataset里的自定义属性

~~~js
//给外层的大盒子绑定的进行路由转跳的函数
goSearch(event) {
    //通过事件对象的target获得被点击的dom元素
    let element = event.target;
    let {categoryName,category1id,category2id,category3id} = element.dataset;
	//我们只给a标签添加了自定义属性categoryName，先通过有没有categoryName判断点击的是不是a标签
	//然后分别给三级联动的一二三级a标签添加自定义属性category n id，通过这个属性判断是几级的a标签，不同级的a标签传递不同的参数
    if(categoryName) {//如果是a标签
        //开始构造路由转跳的参数
        let location = {name:"search"};
        //构造query参数
        let query = {categoryName: categoryName};
        if(category1id) {
            query.category1id = category1id;
        }else if(category2id) {
            query.category2id = category2id;
        }else {
            query.category3id = category3id;
        }
        location.query = query;
        //路由转跳
        this.$router.push(location);
    }
}
~~~

**自定义属性不管定义时大小写，用`dataset`访问时都转化成了小写，所以上面代码中`let{categoryName,category1id,category2id,category3id} = element.dataset;`应该把categoryName改成categoryname，不然categoryName一直都是undefined。**

## 15.search组件中TypeNav组件的三级联动部分进行显示和隐藏

因为不是整个TypeNav的显示和隐藏，所以显示和隐藏的逻辑不能作用于search中的<TypeNav>,必须把显示和隐藏的逻辑写在<TypeNav>组件的内部，通过`this.$route.path`不同区分search中的TypeNav还是Home中的TypeNav，也就是增加逻辑：当`this.$route.path === "/search"`的时候，进行部分的显示和隐藏。

## 16.search组件中三级联动部分从上往下出现的vue动画效果

transition详细博文：[(38条消息) Vue — transition实现过渡动画_@Demi的博客-CSDN博客_vue的transition过渡动画](https://blog.csdn.net/qq_38128179/article/details/118934676)

### vue动画知识点：

vue动画使用条件：给使用了条件渲染（`v-for`/`v-if`)的dom元素或者组件使用<transition>包含，就可以给它添加动画效果：

自动生成几个动画相关的css类：

* `v-enter-active`:dom元素生成的整个阶段的样式，一般可以设置`transition:transform .5s;`表示生成阶段持续0.5s，生成阶段包含开始状态和结束状态，对应类：
  * `v-enter`
  * `v-enter-to`
* `v-leave-active`:dom元素消失的整个阶段的样式，包含消失的开始状态和结束状态：
  * `v-leave`
  * `v-leave-to`

但是<transition>一旦设置的name属性，那么生成的css类名中将用name值代替v。

### 实现分类列表从上往下出现的效果：

~~~html
<transition name="sort">
	<div class="sort" v-show="show">
        ...
    </div>
</transition>
~~~

~~~css
.sort-enter{
    height: 0px;
}
.sort-enter-to{
    height: 461px;
}
.sort-enter-active{
    transition: all .5s linear;
    //all代表选中sort-enter和sort-enter-to中的所有样式设置过渡效果
}
~~~

## 17.合并路由转跳时同时传递params参数和query参数（需要保留目前已有的参数）

我们由home组件转跳到search组件时，通过搜索框会传递params参数，通过三级联动分类点击会传递query参数，所以我们要考虑如果目前先点击了三级联动，拥有了query参数，这时点击搜索，需要在保留query参数的条件下增加params参数，同样如果先搜索再点击三级联动，也要保留以前的params参数。

构造push的转跳参数location时：

* 保留已有的params参数：

`location.params = this.$route.params;`

* 保留已有的query参数：

`location.query = this.$route.query;`

plus:这里没必要判断是否拥有params参数或者query参数再添加，比如`if(this.$route.params){location.params = this.$route.params;}`,因为`$route`里不管有没有query参数或者params参数，都有query空对象和params空对象，this.$route.params和this.$route.query都是存在的。

## 18.mock（模拟）轮播图数据

1. 首先安装mock依赖：`npm install mockjs`

2. src下建立mock文件夹，里面创立相应的json文件，json文件里面存放json数据，把mock数据需要的图片（json文件中保存图片路径，路径都以“/”开头，因为我们这是在做一个项目，即使后台数据用mock模拟，但也要保证项目打包之后能正常运行，为了能保证json文件中对应的图片能正确访问，我们就要把他放在打包之后仍然能访问的位置）图片放到public文件夹中，（public文件夹在打包的时候，会把相应资源原封不动的放到dist文件夹下）
3. 建立mockServe.js文件，利用mockjs创建相应的ajax请求拦截服务

~~~js
//先引入mockjs模块,Mock是一个对象，身上有一个mock方法，可以创建拦截请求的服务，指定拦截地址和设置返回数据
import Mock from 'mockjs';
//把JSON数据格式引入进来[JSON数据格式根本没有对外暴露，但是可以引入]
//因为webpack默认对外暴露的文件类型：图片、JSON格式数据
import banner from './banner.json';
import floor from './floor.json';

//mock数据:第一个参数是伪造的请求地址，可以向这个地址发请求   第二个参数：想让请求返回的数据
Mock.mock("/mock/banner", { code: 200, data: banner });//模拟首页大的轮播图的数据
Mock.mock("/mock/floor", { code: 200, data: floor });

~~~

4. 在main.js中引入，只是指定执行mockServe.js文件一次即可，main.js:

~~~js
import "@/mock/mockServe.js";
~~~

5. 我们不能用以前封装的axios（给服务器发请求的axios）给mock发请求，因为以前的axios的baseURL是'/api'，现在mock服务的请求baseURL是'/mock'，api文件夹下新建一个"mockRequest.js"，除了baseURL配置其余拷贝'request.js'。

6. 用新建的mockRequest封装的axios在@api/index.js里封装请求函数并暴露即可。

   @api/index.js：

   ~~~js
   ...
   import mockRequest from './mockRequest';
   ...
   export const reqGetBannerList = ()=>mockRequests.get('/banner');
   //mockRequest设置了baseURL为'/mock'，路径拼装起来"/mock/floor"对应Mock.mock函数第一个参数
   ~~~


## 19.利用swiper插件制作ListContainer组件中的轮播图

### 基本swiper使用：

1. 给项目安装5版本swiper：

`npm install swiper@5`

2. 在官网（[Swiper使用方法 - Swiper中文网](https://swiper.com.cn/usage/index.html)）粘贴过来相应的html结构，然后引入用到的css类：

`import "swiper/css/swiper.css"`

​	引入css文件直接import后跟对应的css文件即可，引入位置可以在用到swiper的组件中，但如果项目中多处用到轮播图，也可以在入口文件执行上面的语句（我们的选择）。

3. 引入了结构和样式之后swiper是一个静态的，我们需要创建swiper实例，`import Swiper from 'swiper';    var mySwiper = new Swiper('.swiper',{配置对象});`实例创建之后结构轮播图就是动态的了。需要注意的是**轮播图实例创建必须在html结构存在之后，否则无效，相当于创建swiper实例是对已有的html进行一次激活，如果html不存在，就相当于无效激活。所以就存在一个创建swiper实例的时机的问题。**

### swiper实例化的时机问题：

1. 不可以在组件mounted生命周期中实例化：

mounted是指组件挂载完毕，此时理论上结构已经加载完毕，但有种特殊情况：那就是这里轮播图的结构是遍历bannerList生成的，但bannerList是通过axios异步获取的数据，**mounted时异步数据并没有生成**，所以不能在mounted中实例化swiper。

2. 不在update中实例化：

确实可以激活轮播图，但因为每次组件任何响应式数据更新都重新实例化swiper，浪费资源。

3. 在mounted中用setTimeout包装实例化操作：

可以实现效果，但延时长导致体验差，延时短又容易出bug（这里不是js宏任务微任务的情况，延时短可能setTimeout先于axios）。

### 最优解决方案：watch+nextTick

监听bannerList的变化，但是我们因为**vue的模板渲染机制：在所有代码执行完毕之后才去更新模板，所以即使watch函数中修改了bannerList数据，紧接着实例化swiper的话html中还是没有结构，所以我们要把实例化swiper放在nextTick中**。（nextTick就是指下一次模板更新完毕后执行其回调函数）

~~~js
watch: {
    bannerList(newValue,oldValue) {
        this.$nextTick(()=>{
            var mySwiper = new Swiper(...);
        });
    },
}
~~~

### vue中用ref获取dom结点（new Swiper的第一个参数）：

~~~html
<div ref="mySwiper">
    ...
</div>
~~~

~~~js
var mySwiper = new Swiper(this.$refs.mySwiper,{...});
~~~

## 20.动态展示floor组件数据

没什么新知识点，思路梳理：

1. 写api里请求floor数据的函数

2. 在home组件里发请求，vuex三连环，然后用mapstate获取vuex里的数据（floor组件在home组件里复用两次，请求来的数据是一个数组，里面俩对象分别属于两个不同的floor）

   ~~~html
   <Floor v-for="floor in floorList" :key="floor.id" :list="floor"/>
   ~~~

3. floor组件里props接收传来的数据，然后用这个数据动态渲染html即可。

## 21.提取轮播图为全局组件

因为在ListContainer组件和Floor组件中都存在轮播图，它们的html结构相同，我们可以把它提取出来，然后声明为一个全局组件。我们需要把js部分也统一起来，原本ListContainer中轮播图swiper实例化是在watch+nextTick实现，在Floor中是mounted时实例化swiper，在Carousel（轮播图）组件中我们采用watch+nextTick实现轮播图实例化。然后轮播图播放的图片是遍历的数组决定的，所以我们在其他组件中使用<Carousel>组件时需要传给它一个数组参数，在<Carousel>组件中用props接收使用。

## 22.search模块开发

模块开发思路：

1. 写静态页面+静态组件拆分出来
2. 发请求（API）
3. vuex三连环存储数据+组件中获得vuex中的数据
4. 组件中动态展示数据

## 23.获取search组件的服务器数据

1. api文件夹中定义方法：这里没用`axios.get/post`的方法发请求，而是调用了`axios`方法：

   ~~~js
   export const reqGetSearchInfo = (params) => requests({
       url:"/list",
       method:"post",
       data:params,
   })
   //axios方法的配置对象的data项必须有，起码是个空对象，所以调用reqGetSearchInfo函数时，至少传入一个空对象
   ~~~

2. vuex的search模块中三连环去运用`reqGetSearchInfo`方法:

   ~~~js
   import { reqGetSearchInfo } from "@/api";
   const action = {
       //reqGetSearchInfo至少接收一个空对象，所以用默认参数的写法：params={}
   	async getSearchList({commit},params={}) {
           let result = await reqGetSearchInfo(params);
           if(result.code === 200) {
               commit("GETSEARCHLIST",result.data);
           }
       }
   }
   ~~~

3. （在某个时机）发请求得数据。

## 24.Search组件使用mapGetters获取vuex数据

vuex的store模块中：

~~~js
const getters = {
    //getters中计算属性接收到的state是本模块的state
    goodsList(state) {
        //searchList如果为空对象，goodList就是undefined，不能进行遍历，所以要保证goodsList至少是一个空数组(保证计算属性是一个符合类型要求的变量)
        return state.searchList.goodsList||[];
    },
	...
};
~~~

vuex的所有模块getters属性共享，也就是说不管home模块还是search模块，声明的getters数据在组件中用mapGetters获取的时候直接可以访问到，而不用区分模块

Search组件：

~~~js
computed: {
    //直接可以访问goodsList，同样能直接访问home模块中定义的getters数据
	...mapGetters(['goodsList']),
}
~~~

## 25.配置`dispatch("getSearchList",params)`的params参数：Object.assign合并对象/Search组件根据不同参数发送请求获取数据

1. 配置search组件的data数据：searchParams

   ~~~js
   data() {
     return {
       searchParams: {
         //三级联动点击参数
         category1Id: "",
         category2Id: "",
         category3Id: "",
         categoryName: "",
         //搜索参数
         keyword: "",
         //排序功能相关参数
         order: "",
         //分页器当前页数
         pageNo: 1,
         //每页呈现几个产品
         pageSize: 10,
         //平台售卖属性相关参数（面包屑下面的表格呈现的属性）
         props: [],
         //代表哪个品牌
         trademark: "",
       },
     };
   },
   ~~~

2. 利用$route的query和params参数修改data

   ~~~js
   beforeMount() {
       //Object.assign:把第一个对象往后的对象有的属性给第一个对象，如果属性同名则后面对象的属性值覆盖第一个对象的属性值
   	Object.assign(this.searchParams,this.$route.query,this.$route.params);
   },
   ~~~

   

3. dispatch("getSearchList",this.searchParams);

   ~~~js
   methods: {
       getData() {
           this.$store.dispatch("getSearchList", this.searchParams);
       }
   },
   mounted() {
   	this.getData();
   },
   ~~~

   但是放在mounted中发请求显然是不合适的，因为请求只会在第一次进入search组件时发送一次，后续即使参数更改数据也不会重新发送请求。

## 26.发出Search组件数据请求的时机---->监听$route变化

mounted钩子中只发送第一次请求Search组件数据的请求，需要改进为不管是点击三级联动还是点击搜索，都要根据新的参数重新发送请求获取数据。

解决方案：监视$route，$route本身也是组件的一个数据项，和data中的数据同级，自然可以监视。

~~~js
watch: {
    $route(newValue,oldValue) {
        //检测到$route发生变化，我们要重新发送数据请求，第一件事就是构造请求的参数
     	Object.assign(this.searchParams, this.$route.query, this.$route.params);
        this.getData();
        //因为三级联动的点击参数category1id、category2id、category3id三者每次只能有一个，不能因为这一次请求给this.searchParams添加了其中一个，然后一直携带到以后的请求，所以每次请求完毕后重置categoryId为空
        this.searchParams.category1Id = "";
        this.searchParams.category2Id = "";
        this.searchParams.category3Id = "";
    }
}
~~~

## 27.面包屑的展示与删除

展示：面包屑展示的内容与categoryName绑定，`v-show="categoryName"`即可

删除：点击`×`绑定`removeCategoryName`函数，删除面包屑的逻辑核心就是清除请求的query参数（保留params参数）重新发出没有query参数的请求。

~~~js
removeCategoryName() {
    //1.清除query参数
    this.searchParams.categoryName = undefined;//接口规定为可选参数，设置为undefined就不存在这个参数,可以节省请求时的内存
    this.searchParams.category1id = undefined;
    this.searchParams.category2id = undefined;
    this.searchParams.category3id = undefined;
    //2.更改路由（同时路由更改触发新的请求---无query参数的请求）
    this.$router.push({ name: "search", params: this.$route.params });
}
~~~

keyword相关的面包屑处理与categoryName面包屑类似：在删除keyword面包屑之后清除params参数并重新请求数据，但需要全局事件总线清除Header组件里的搜索框的值。

trademark相关的面包屑：品牌列表是在Search的子组件SearchSelector中v-for遍历trademarkList生成的，我们点击了某个品牌之后，需要把trademark的信息传给父组件（Search组件），因为我们构造的用来请求的数据searchParams在父组件中：子组件传递数据给父组件用自定义事件实现，然后在Search组件中构造请求参数发送请求。和上面点击面包屑和搜索面包屑不同：**trademark信息不是路由参数（他就是search组件内部的行为产生的参数，所以不是路由参数，路由参数是其他组件转到某个路由组件时传递的参数）所以发送请求直接调用`this.getData();`**，而不是`this.$router.push`（其他两种面包屑通过路由转跳可以触发对$route的watch，自动发送请求）。

## 28.bug修改：search组件中categoryId和categoryName全部改为小写

search组件data中categoryId和categoryName的作用就是结合$route的query参数（`Object.assign(this.searchParams, this.$route.query, this.$route.params)`）发出数据请求，因为$route中query参数中是categoryid和categoryname（TypeNav构造向Serach组件转跳的query参数时用的vue自定义数据实现，自定义数据不管标签中是大小写，但通过element.dataset访问时都是小写），所以我们修改Search组件中数据也全为小写。

## 29.平台售卖属性的点击效果

效果：点击平台售卖属性之后，根据选择属性重新发送数据请求，并保存相应的面包屑（可存在多个）

实现思路：SearchSelector组件中，某个属性被点击，整理被点击的属性信息（属性id，属性类型，属性值）通过自定义事件传递给父组件（Search组件）,父组件更新data中的props数组之后重新发送请求，并且遍历props生成面包屑，当面包屑被删除时同样更新props并重新发送请求。

## 30.排序选项的实现

searchParams中的order参数共有四种情况：”1：desc“，”1：asc“，”2：desc“，”2：asc“。1代表综合排序，2代表价格排序；desc代表降序，asc代表升序。

* 根据order中是1还是2动态给html中的选项添加类

  ~~~html
  <li :class="{active:searchParams.order.split(':')[0]==='1'}">
  	<a>综合</a>
  </li>
  ~~~

  或者

  ~~~html
  <li :class="{active:searchParams.order.indexOf('1')!==-1}">
  	<a>综合</a>
  </li>
  ~~~

  可以把`searchParams.order.indexOf('1')!==-1`封装成一个计算属性

  ~~~html
  <li :class="{active: isOne}">
  	<a>综合</a>
  </li>
  ~~~

  ~~~js
  computed:{
  	isOne() {
          return this.searchParams.order.indexOf('1')!==-1;
      }
  }
  ~~~

* 被order选中的（有类的）选项 文字后面有箭头符号：`v-show`

  ~~~html
  <li :class="{active: isTwo}">
      <a>价格<span v-show="isTwo">箭头</span></a>
  </li>
  ~~~

* 用阿里图标库获取箭头图标

  找到图标的在线css样式地址：//at.alicdn.com/t/c/font_3641358_j8roxg2sejt.css，加上https协议在public文件夹下的index.html中引入

  ~~~html
  <link rel="stylesheet" href="https://at.alicdn.com/t/c/font_3641358_j8roxg2sejt.css">
  ~~~

  引入类之后，只要我们给一个盒子元素用上iconfont类以及图标本身对应的类（`<span class="iconfont icon-arrowup"></span>`），这个盒子中就会出现icon-arrowup对应的符号。

  根据order参数是否包含asc或者desc字符决定是上升箭头还是下降箭头（计算属性：`isAsc() {return this.searchParams.order.indexOf("asc") !== -1;},`）

  ~~~html
  <li :class="{active: isOne}">
      <a>综合<span v-show="isOne" class="iconfont" :class="{'icon-arrowup': isAsc,'icon-arrowdown': isDesc}"></span></a>
  </li>
  ~~~

* 给排序选项按钮绑定点击事件，实现：连续点击相同按钮更换升降序，点击不同按钮更换排序方式，默认为降序。

  ~~~js
  changeOrder(flag) {
  	let originFlag = this.searchParams.order.split(":")[0];
      let originSort = this.searchParams.order.split(":")[1];
      //连续点击同一个按钮，flag不变，更换升降序
      if(flag === originFlag) {
          this.searchParams.order = `${flag}:${originSort === "desc" ? "asc" : "desc"}`;
      }else {//点击不同按钮，更换flag
          this.searchParams.order = `${flag}:${originSort}`;
      }
      this.getData();
  }
  ~~~

  

## 31.Pagination--分页器的实现（自定义分页功能）

使用分页器的原因：比如电商平台同时展示的数据量太大，采用分页功能，只渲染展示当前页面的数据。（ElementUI有分页组件，使用简单，但我们不用，以学习分页实现原理）

分页器需要的相关数据：

* 需要知道当前是第几页：`pageNo`
* 需要知道每一页展示多少条数据：`pageSize`
* 需要知道整个分页器一共有多少条数据：`total`
  * 结合上面两点可知道一共多少页`totalPage`
* 需要知道分页器两侧省略号中间有多少个连续页面选项：`continues`，一般是5或者7（奇数），对称、美观。

### 完成分页器的动态展示

所谓分页器的动态展示就是，根据分页器的配置数据，决定一部分html结构的显示和隐藏，具体来说就是分页器的中间部分稳定展示，**用`v-for`遍历数字startNumAndEndNum.end并结合`v-show`隐藏startNumAndEndNum.start之前的数字 生成结构**，分页器前面部分的“1”和“...”、分页器后面的“...”和“totalPage”根据中间部分的起始位置和结束位置适时隐藏掉。

~~~html
<button>上一页</button>
<button v-show="startNumAndEndNum.start>1">1</button>
<button v-show="startNumAndEndNum.start>2">···</button>

<!-- 分页器中间部分 -->
<!-- 中间部分稳定呈现，上部分“1”和“...”和下部分的“...”和“totalPage”根据情况隐藏 -->
<button v-for="(page,index) in startNumAndEndNum.end" :key="index" v-if="page>=startNumAndEndNum.start">{{page}}</button>


<button v-show="startNumAndEndNum.end<totalPage-1">···</button>
<button v-show="startNumAndEndNum.end<totalPage">{{totalPage}}</button>
<button>下一页</button>

<button style="margin-left: 30px">共 {{totalPage}} 条</button>
<div>{{startNumAndEndNum}}</div>
~~~

父组件传递真实分页器数据给`Pagination`组件，并且监听分页器的自定义事件`changePageNo`（得知分页器被点击之后应该切换到哪一页，自定义事件实现子组件给父组件传递信息），给分页器组件中所有可以点击的按钮添加click事件监听，触发自定义事件`changePageNo`并传递应该切换到的页号：`<button :disabled="pageNo===1" @click="$emit('changePageNo',pageNo-1)">上一页</button>`（还得给上一页和下一页动态设置disabled属性）。父组件添加自定义事件`changePageNo`的回调`changePageNo`方法，修改`pageNo`数据并重新发送数据请求。

**面试时被问是否封装过组件——分页器！**

## 32.Detail组件（点击商品图片时router-link进行跳转）开发--静态组件+配置路由

跳转到Detail组件时携带商品id（params参数）

## 33.路由跳转滚动条行为

实例化VueRouter时添加与routes同级的配置项--scrollBehavior，用来设置转跳到新路由时滚动条的位置。

~~~js
export default new VueRouter({
    routes: [...
    ],
    //跳转到一个新路由时滚动条位置的设置：新路由页面中滚动条在最上面
    scrollBehavior(to, from, savedPosition) {
        // return 期望滚动到哪个的位置
        return { y: 0 };
    }
})
~~~

## 34.一种隐性报错（不影响程序运行）

在vuex中我们向服务器捞商品数据的时候，服务器预期返回的数据goodInfo是一个对象，那么我们就要在state中给goodInfo初始化为一个空对象，然后Detail组件需要goodInfo中的一个对象skuInfo，在getters中创建skuInfo，这时候就不能直接return state.goodInfo.skuInfo，还要或上一个空对象，因为如果不或上空对象，其他组件获得getter中的skuInfo的时候，服务器数据在最开始的时刻可能还没请求到（goodInfo是空对象），goodInfo.skuInfo自然是undefined，其他组件这时候接收到的skuInfo就是一个undefined，自然其他组件如果使用skuInfo，就会报错（TypeError: Cannot read properties of undefined），相当于去访问undefined的某个属性。

然后在Detail组件中，它有一个子组件Zoom（放大镜）,这个组件需要skuInfo对象中的一个数组数据skuImageList，我们在给Zoom传递skuImageList的时候，同理，也需要或上一个空数组，要不然Zoom在使用skuImageList的时候，服务器数据未到达，Zoom中skuImageList是undefind，如果访问undefined的某一项，自然也会报错。

甚至在Zoom中我们只使用skuImageList的第一项的某个属性（skuImageList[0].imgUrl，plus：数组的每一项都是一个对象）,这时候skuImageList[0]可能是undefined，所以我们在Zoom组件内部，都需要一个计算属性imgObj：return skuImageList[0]||{}。

这种bug虽然只是控制台报错（在服务器数据到达之前的很短时间内报错）但不影响程序运行（如果服务器正常的情况下），但原理就是因为数据是在服务器那边获得的，数据在vuex、父组件、子组件中传递时，服务器数据可能没来，父组件获得的vuex中的数据可能是undefined，子组件获得的父组件中的数据可能是undefined，如果使用这些undefined，自然会报错，所以解决方案也很简单，**在vuex中写getters属性时、在父组件中写计算属性（用来传给子组件）时，都根据要传递的这个数据的类型，给它或上一个同类型的空数据即可。**

## 35.数组排他操作实现被选择的商品属性高亮

当有属性值被点击时，高亮属性是我们通过spuSaleAttrValue的isChecked属性为1时动态添加的，我们给回调函数传入spuSaleAttrValueList，所谓排他操作就是把所有spuSaleAttrValue的isCheck都清空为0，然后设置被选中的那一个为目标值（先毁灭全部，再重新设置）

## 36.放大镜区域与下方轮播图展示同步

放大镜与下方轮播图属于兄弟组件，两者里面都配置一个currentIndex的data项用来统一选中的图片。底部轮播图某图片被点击，通知兄弟组件放大镜。用到了全局事件总线通信方式。

## 37.放大镜的绿色遮罩层随鼠标移动

### 知识点：

#### 鼠标位置相关

* screenX与screenY，参照点是屏幕的左上角
* clientX与clientY，参照点是浏览器内容区域的左上角（不算导航栏），这个参照点会随着滚动条的移动而移动
* pageX和pageY，同client，参照点是浏览器内容区域的左上角，但是参照点不会随着滚动条而变动
* offsetX和offetY，参照点是事件源元素的左上角

#### dom大小相关

* `HTMLElement.offsetWidth`：返回当前dom元素的包含border在内的宽度
* `HTMLElement.offsetHeight`：返回当前dom元素包含border在内的高度

首先绿色遮罩层肯定是一个定位元素（是大图的子元素，在大图里面移动），我们需要通过鼠标移动事件的位置属性（offsetX、offsetY：参照点为父元素）结合dom元素（利用ref获取）的大小属性动态计算出它的定位的属性值。然后随着鼠标移动事件实时修改其样式即可。

plus：放大镜放大图片的那一部分具体实现原理不清楚（为什么是给img图片的定位元素设置-2*left...），但不重要，我们只知道实现原理是动态修改定位样式即可。

## 38.input收集购买产品个数，规范化用户输入

<input>的change事件（输入框失去焦点）的回调：

~~~js
changeSkuNum(event) {
  //用户输入进来的文本*1，不影响正常数量，但如果输入非数字，会得到NaN
  let value = event.target.value * 1;
  //如果用户输入非法---出现nan或者小于1
  //通过isNaN方法判断一个值是否为NaN
  if(isNaN(value) || value < 1) {
    this.skuNum = 1;
  }else {
    //如果是正常数字且大于一，转换成整数即可
    this.skuNum = parseInt(value);
  }
},
~~~

## 39.加入购物车成功或者失败的判断

我们加入购物车的行为除了路由转跳之外，我们首先要向服务器发送请求，这个请求不同于以往的请求（以往的请求目的是向服务器捞数据），而这个请求的目的就是通知服务器我们添加购物车的行为，服务器返回的数据中仅仅存在成功或者失败状态的信息，而没有我们需要的具体的数据。所以我们在vuex中只有一个actions方法，目的就是向服务器发一个请求，而没有后续的mutations函数以及state数据存储。所以这就有一个问题：我们在Detail组件中（dispatch加入购物车行为的组件）怎么才能知道vuex中actions函数给服务器发送的加入购物车的请求是否成功了呢？

首先先说dispatch方法，其实是有返回值的，而且返回值是一个promise对象，返回的promise具体的状态怎么确定我没查，但这里我们没必要弄清，因为我们直接把vuex里actions发送请求的方法定义成`async`函数，此时dispatch的返回值就是actions方法的返回值，这样我们直接按`async`函数的返回规则就行了。

plus：async函数返回规则：

* 返回一个promise对象
* **没有显式调用return，如果await都成功，那么相当于`return Promise.resolve(undefined)`；如果 await 后面的异步操作出错，那么返回rejected的promise**
* return一个普通值x（非promise对象），相当于`return Promise.resolve(x);`
* return promise对象，那么就直接返回这个promise对象
* 如果

我们想拿到vuex中actions发请求的情况（成功还是失败），因为actions中的函数是async函数，所以我们根据dispatch的返回值就可以知道请求是否成功了

vuex中：

~~~js
async addOrUpdateShopCart({commit}, {skuId,skuNum}) {
    //加入购物车返回的结果
    let result = await reqAddOrUpdateShopCart(skuId, skuNum);
    //加入购物车是我们前台带着参数通知服务器的操作，服务器返回的数据里也没有data项，所以我们自然也不用vuex3连环存储数据
}
~~~

如果`reqAddOrUpdateShopCart`请求成功，那么就相当于没有显式return，返回一个成功的promise；如果请求失败，相当于没有显示return，返回一个失败的promise。为了能判断`dispatch`返回的promise的状态成功还是失败，我们可以用`try-catch`模块，try-catch模块不能捕获普通的rejected的promise，但是可以捕获await解析的失败的promise。所以我们为了用try-catch来判断dispatch返回的promise是成功或者拒绝，我们直接给Detail组件中的addShopcar方法也写成async函数，然后直接用await接收dispatch函数，然后用try包裹成功的逻辑，catch包裹失败的逻辑

Detail组件中：

~~~js
async addShopcar() {
  try {
    await this.$store.dispatch('addOrUpdateShopCart', {skuId:this.$route.params.skuid,skuNum:this.skuNum})
    //如果上面的promise状态为成功，那么继续执行try中往下的代码(路由转跳之类的)，如果状态为失败，那么直接进入catch块
    ...
  } catch(error) {
    //如果dispatch返回了一个rejected的promise，也就相当于vuex中发请求失败了，执行catch部分的代码（提示用户加入购物车失败...）
    alert("加入购物车失败");
  }
}
~~~

可能会问：为什么不在Detail组件中发请求，直接就能拿到请求服务器究竟成功还是失败的信息，因为我们联系服务器的请求习惯都是在vuex中进行发送。

可以在vuex的actions函数中，显式调用return，增加一些代码可读性。

## 40.路由传参（Detail—>购物车）结合会话存储（浏览器存储属于H5新特性）

浏览器本地存储

* `localStorage.setItem(keyString, valueString)`：不删除便永久存储
* `localStorage.getItem(keyString)`
* `sessionStorage.setItem(keyString, valueString)`：存在于打开的浏览器页面，关闭此标签页数据就会消失
* `sessionStorage.getItem(keyString)`

本地存储key值对应的value都是字符串，所以如果我们存储一个对象的话，需要先`JSON.stringify`转化为JSON字符串，然后读取时再`JSON.parse`将JSON字符串转化成对象。（如果直接setItem时value值写为对象，会调用Object.toString方法把对象转化成[Object Object]）

在Detail路由组件向购物车组件转跳时，query路由参数只携带一个skuNum，复杂的产品信息数据（嵌套型对象）我们使用会话存储。

## 41.利用uuid标识用户，获取uuid对应用户的购物车数据

我们发送请求获取购物车数据的时候，这个数据一定是属于请求的个人的，所以需要一个属于请求者的唯一标识。我们用uuid模拟生成一个随机字符串模拟这个用户标识。

我们先建立一个utils文件夹（实用工具），这个文件夹里建立文件uuid_token.js里面定义函数getUUID，这个函数利用uuid库来生成用户的唯一标识（借助localStorage，无则生成，有则读取）

`@/utils/uuid_token.js`：

~~~js
import { v4 as uuidv4 } from 'uuid';
export const getUUID = () => {
    //先从本地存储获取uuid（看一下本地存储是否有）
    let uuid_token = localStorage.getItem('UUIDTOKEN');
    //如果没有，我们就生成一个游客临时id，并且本地存储
    if(!uuid_token) {
        uuid_token = uuidv4();
        localStorage.setItem('UUIDTOKEN',uuid_token);
    }
    return uuid_token;
}
~~~

我们把生成的用户唯一标识uuid_token存放在detail仓库中，在商品详情仓库的state中直接调用getUUID方法获取用户临时id。（也就是说这个vuex数据并不是通过发请求三连环得到的）

`@/store/detail/index.js`

~~~js
import { getUUID } from "@/utils/uuid_token";
const state = {
    goodInfo: {},
    //游客临时身份
    uuid_token: getUUID()
};
~~~

我们这个uuid_token计划是放在请求头的userTempId字段中的（后端设计）所以我们要在请求拦截器中捞到仓库数据（uuid_token），才能使用uuid_token（信息放到请求头中），所以我们在封装axios的模块中引入仓库，然后读取仓库中的uuid_token并将其放在请求头中。

`@/api/request.js`：

~~~js
...
//在当前模块中引入store
import store from '@/store';
...
//请求拦截器
requests.interceptors.request.use((config)=>{
    nprogress.start();
    //config:配置对象，对象里面有一个属性很重要：headers--请求头
    if(store.state.detail.uuid_token) {
        //给请求头添加一个字段（userTempId）
        config.headers.userTempId = store.state.detail.uuid_token;
    }
    return config;
});
~~~

这样我们发送获取购物车数据请求的时候，（因为请求头已经就位，后端设计的条件都已满足），我们就能正确获得数据。

## 42.修改购物车产品数量

修改产品数量相关的html结构：

~~~html
<li class="cart-list-con5">
  <!-- 三者共用同一回调 -->
  <a
    href="javascript:void(0)"
    class="mins"
    @click="handler('minus', -1, cart)"
    >-</a
  >
  <!-- 乘一：参数预处理 -->
  <input
    autocomplete="off"
    type="text"
    :value="cart.skuNum"
    minnum="1"
    class="itxt"
    @change="handler('change', $event.target.value * 1, cart)"
  />
  <a
    href="javascript:void(0)"
    class="plus"
    @click="handler('add', 1, cart)"
    >+</a
  >
</li>
~~~

（一个减号，一个输入框，一个加号），三者共同实现修改购物车的购买数量功能，我觉着是为了代码的质量提高（一个函数处理一个功能，总比三个函数简洁），所以我们让三者共用同一回调`handler`，虽然三者共用同一回调，但代码逻辑肯定是完全不同的，所以我们首先要区分三者中是哪一个触发了回调，我们直接用传递标识型字符串参数的形式，`handler`的第一个参数就是标识性字符串，我们只需在函数体内`switch`即可（不同case处理不同逻辑）。

然后我们思考修改购物车产品数量本质上就是做了两件事：

* 给服务器发请求，修改服务器的存储（用户的购物车信息是由服务器存储的）
* 获取到最新的服务器数据，然后我们展示

修改服务器存储的回调需要我们商品数量的变化值，所以handler的第二个参数加号和减号的情况我们直接传1和-1，然后input的时候为了方便我们传递input的值，留到函数体内再进行计算。但是给input传递这个值的时候我们给input的value乘一，相当于预处理，结合函数体内`isNaN`方法就可以判断那些非数字的非法输入。

我们给服务器发请求还是获取最新服务器数据都需要产品信息，`handler`的第三个参数传产品信息对象。

~~~js
//定义async函数目的完全同39.(因为服务器dispatch之后服务器不返回数据，所以利用dispatch的返回值判断actions中的请求是否成功)
async handler(type, disNum, cart) {
  //type用来区分触发事件的三个元素
  //disNum形参——+:变化量为1;-:变化量为-1;input:最终的个数（不是变化量）
  //哪一个产品（身上有id属性）
  //向服务器发请求修改存储的购买数量
  switch (type) {
    //加号
    case "add":
      disNum = 1;
      break;
    //减号
    case "minus":
      //对于简单的赋值操作的if-else语句，我们可以直接用三元表达式代替
      disNum = cart.skuNum > 1 ? -1 : 0;
      break;
    case "change":
      //如果用户输入非法（非数字）或者负数,带给服务器数字0（原封不动）
      if (isNaN(disNum) || disNum < 1) {
        disNum = 0;
      } else {
        //正常情况（小数需要取整）,带给服务器变化量 = 用户输入 - 产品起始个数
        disNum = parseInt(disNum) - cart.skuNum;
      }
      break;
  }
  //派发action
  try {
    //请求向服务器修改存储的购物车数据
    await this.$store.dispatch("addOrUpdateShopCart", {
      skuId: cart.skuId,
      skuNum: disNum,
    });
    //如果修改成功下面获取服务器最新数据进行展示
    this.getData();
  } catch (error) {}
},
~~~

## 43.删除购物车产品

这里删除的相关请求也是属于向服务器发送请求，但服务器不返回数据的那种请求，所以总结一下。vuex三连环的请求一般都是查询请求（查），向服务器索取数据，然后上面遇到的添加或更新购物车（增、改）这种请求和这里的删除请求（删）类似，都是发请求让服务器去做一些事情，服务器并不返回具体数据，我们只需要知道操作是否成功即可。

这种请求的写法套路就是：

封装好api函数之后vuex里的actions正常调用请求函数，但是不用commit了，需要的是把actions中的方法写成async函数，用`await`获取请求结果`result`后根据`result.code`return（不显示return也可以，但不好），成功的话（`result.code==200`）return一个普通值（相当于`Promise.resolve()`）,失败的话return一个`Promise.reject(new Error("faile"))`。然后我们在组件中（删除按钮，添加按钮）的回调函数中接收`dispatch`的值，用`await`接收`dispatch`，所以自然回调也是`async`函数，把`await this.$store.dispatch`放在`try`中，因为try能捕获rejected的promise对象，所以自然达到了判断请求是否成功的目的。（try中后面的代码为请求成功之后的逻辑，catch中为请求失败的逻辑）

## 44.购物车减号如果高频点击会出现负数，使用节流进行优化

~~~js
import throttle from "lodash/throttle.js";
...
handler:throttle(async function(type, disNum, cart) {
  //type用来区分触发事件的三个元素
  //disNum形参——+:变化量为1;-:变化量为-1;input:最终的个数（不是变化量）
  //cart:哪一个产品（身上有id属性）
  //向服务器发请求修改存储的购买数量
  switch (type) {
    //加号
    case "add":
      disNum = 1;
      break;
    //减号
    case "minus":
      //对于简单的赋值操作的if-else语句，我们可以直接用三元表达式代替
      disNum = cart.skuNum > 1 ? -1 : 0;
      break;
    case "change":
      //如果用户输入非法（非数字）或者负数,带给服务器数字0（原封不动）
      if (isNaN(disNum) || disNum < 1) {
        disNum = 0;
      } else {
        //正常情况（小数需要取整）,带给服务器变化量 = 用户输入 - 产品起始个数
        disNum = parseInt(disNum) - cart.skuNum;
      }
      break;
  }
  //派发action
  try {
    //请求向服务器修改存储的购物车数据
    await this.$store.dispatch("addOrUpdateShopCart", {
      skuId: cart.skuId,
      skuNum: disNum,
    });
    //如果修改成功下面获取服务器最新数据进行展示
    this.getData();
  } catch (error) {}
},1000),
~~~

## 45.删除全部选中的商品

后端没有提供直接删除全部购物车的接口，所以我们只能借助删除一个商品的接口实现删除全部。我们在vuex中定义一个方法`deleteAllCheckedCart`，这个方法负责遍历整个购物车数据数组，购物车有几个数据项这个方法就派发（dispatch）几个删除请求，所以`deleteAllCheckedCart`方法中我们需要`context`的两个对象：`dispatch`和`getters`，dispatch用来派发，getters用来获取仓库数据（用来遍历发送请求）。然后为了在组件中得知“删除全部购物车选中商品”是否成功，我们用`Promise.all`方法实现，`Promise.all`接收一个数组，里面的promise对象只有都成功，`Promise.all`才返回成功的promise，所以我们在vuex的`deleteAllCheckedCart`方法里每dispatch一个`deleteCartListBySkuId`，我们就把这个dispatch的结果存入数组`PromiseAll`，`deleteAllCheckedCart`方法的最后`return Promise.all(PromiseAll);`，这样我们就可以在组件中用`try-catch`得知删除全部的操作是否成功了。

## 46.全选按钮修改全部产品的勾选状态

套路完全类似于上面删除全部选中的商品，但组件中需要给全选按钮的回调传一个`$event`，因为需要`$event.target.checked`来区分点击全选按钮之后是由不选改为选中，还是选中改为不选。（利用单个操作[比如删除一个、勾选一个]的接口实现群体操作）基本套路：

组件结构：

~~~html
<input @change="checkAll($event)"/>
<span>全选</span>
~~~

组件相关回调：

~~~js
async checkAll(event) {
  //try判断操作是否成功
  try {
    //全选按钮目前的状态
    let currentState = event.target.checked;
    //组件中dispatch，并await接收仓库里的Promise.all
    await this.$store.dispatch('checkAll', currentState);
    this.getData();
  } catch(error) {
    alert("全选失败");
  }
}
~~~

仓库里actions中的方法：

~~~js
//点击全选的函数（全选或者全不选）
checkAll({dispatch, getters}, currentState) {
    //仓库中先创建promise数组，作为Promise.all的参数
    let PromiseAll = [];
    //带给服务器的参数是0|1，而不是布尔值，需要转换
    let params = currentState ? '1' : '0';
    getters.cartList.cartInfoList.forEach(item => {
        //遍历数据，派发进行单个操作的请求
        let promise = dispatch('updateCheckedById', {skuId:item.skuId, isChecked:params});
        PromiseAll.push(promise);
    })
    //返回Promise.all，供组件判断操作是否成功
    return Promise.all(PromiseAll);
}
~~~

此时全选按钮还有两个bug：

* 刚进购物车，购物车里没有商品时仍然处于选中状态  给:check添加判断条件cartInfoList.length>0即可

~~~html
:checked="cartInfoList.length>0&&isAllCheck"
~~~

* 进入购物车，此时全选按钮并没有被选中，但是点击之后虽然cartInfoList.length>0和isAllCheck都仍然不满足，但是还是会变化成选中状态，这时候我们可以操作disabled属性，让input直接无法点击：

~~~html
:disabled="cartInfoList.length<=0"
~~~

## 47.提取精灵图到assets文件夹下

assets文件夹一般存放项目的所有组件共用的资源，（打包时，会被打包--暂不理解），我们提取一张全局的精灵图到assets文件夹下。然后曾经用到这张图的位置（ListContainer组件的css部分）想用@符进行定位这张图片：

~~~css
// 在css文件中使用@符需要前面加一个~
background-image: url(~@/assets/images/icons.png);
~~~

## 48.注册业务

注册业务相关的请求有两个：

* 获取验证码（请求参数：手机号）
* 注册请求（请求参数：手机号、验证码、密码）

注册业务，两个相关的请求都是根据表单信息作为参数的，首先我们肯定要**收集表单数据**：data中配置手机号、验证码、密码...通过`v-model`收集表单数据。

第二步**vuex三连环**，在api文件夹里写（获取验证码）发请求的函数，store文件夹下创建一个新仓库模块`user`，这个仓库用来处理登录注册相关的业务。仓库里引入获取验证码的函数，这个请求理论上讲不是捞数据的请求，是属于命令服务器的请求（通知服务器让服务器给指定手机号发个验证码就行了），所以理想情况下仓库actions里的函数我们只需要定义成`async`向组件返回一下请求是否成功的状态即可，不需要commit等后续仓库操作（用户自己输入二维码即可）。但是服务器端为了省钱，把二维码给到了请求返回的数据里，所以我们通过后续的commit、state环节等在仓库里拿到二维码，组件中在`dispatch`获取二维码之后给data中的code赋值为仓库里的code。这样相当于我们手动帮助用户填写了二维码。（理论上actions中发出请求后vuex里获取二维码的逻辑就结束了）

然后就是注册按钮，先写请求api方法，仓库里只在actions中发请求即可。当然组件中获取二维码和注册两个dispatch的函数都用的`try-catch`结构结合`await`获取`dispatch`的返回值判断操作是否成功，对应的仓库actions中的函数也根据请求结果显式返回（promise对象）。

## 49.登录业务

### 请求部分（获取token）

登录业务相关请求就一个，需要携带账号密码作为参数，首先还是**`v-model`收集表单数据**，写请求api，vuex中引入api方法写actions，然后组件中dispatch。但组件中登录按钮点击之后会自动进行页面跳转，原因是登录的<button>按钮是在<form>标签内部的，某些dom元素有默认行为，比如<form>中的<button>按钮被点击会视为表单提交，触发<form>的默认行为：转跳。（<a>标签被点击默认行为是打开新地址），所以我们给登录的<button>按钮绑定点击事件时需要用到vue修饰符".prevent"来阻止dom的默认行为：`@click.prevent=""`。

上面登录请求返回的数据中包含一些用户信息和`token`（其实接口设计不好，理论来讲只返回token即可，毕竟token就是用户信息的加密形式）。token是要利用`localStorage`进行长期存储的，其实目前来讲我们只是获得了token并把token存放在vuex中而已。

登陆成功后转调至home主页，但是此时的主页需要我们展示用户信息（左上角不是登录/注册按钮，而是用户名）,所以我们要发请求获取用户信息，暂且我们把`this.$store.dispatch("getUserInfo")`放在home组件的`mounted`中。

### token利用部分

这时候请求用户信息的时候并没有携带token，修改请求拦截器增加请求头以携带token信息，在vuex中登录请求获取token之后就立即用`localStorage`存储`token`至本地：

~~~js
//登录业务
async userLogin({commit}, data) {
    let result = await reqUserLogin(data);
    if(result.code === 200) {
		...
        //本地存储token
        localStorage.setItem("TOKEN", result.data.token);
        ...
    }else {
		...
    }
},
~~~

以后token的访问，都去本地存储获取。设置响应头添加token信息：

~~~js
//请求拦截器
requests.interceptors.request.use((config)=>{
    
	...
    
    //携带token
    if(localStorage.getItem('TOKEN')) {
        config.headers.token = localStorage.getItem('TOKEN');
    }
    return config;
});
~~~

目前，我们从未登录的状态登录成功之后本地就会有token的信息，自然以后的请求的请求头也都会携带token，**但目前的问题是**：

* 目前来说需要token的请求就是获取用户信息的请求，毋庸置疑，登录成功之后转跳至home组件肯定要发请求展示用户信息，我们暂且把`this.$store.dispatch("getUserInfo")`放在home的`mounted`里，这样可以确保在home页面刷新的话能正常触发获取用户信息的请求，但是一旦换成其他组件，比如说到了搜索页面，或者到了购物车页面，我们再点击刷新页面不会执行`this.$store.dispatch("getUserInfo");`，也就导致左上角用户信息那里又成登录注册选项了。

* 用户已经登录了，本地也存储了token信息，理论来讲我们不应该能回到登陆页面，但是我们通过修改路径等方式还是可以转跳到登录页面

## 50.退出登录

* 发退出登录请求通知服务器删除token相关信息
* 删除vuex中存储的用户信息以及token，清空本地存储的token

## 51.利用路由守卫—全局前置守卫解决登录后可以返回登录页面的问题和利用token获取用户信息的时机的问题（49遗留的两个问题）

`@/router/index.js`：

~~~js
import store from '@/store';

let router = new VueRouter({...
})

//全局路由守卫：前置守卫（在路由转跳之前执行逻辑）
router.beforeEach(async (to, from, next) => {
    
    /*
    	根据token和name来判断用户的登录状态
    	token是存储在本地的，name是vuex中的
    	如果只有token而没有name，也是已经登录，则需要捞取数据
    */
    let token = localStorage.getItem("TOKEN");
    //根据userInfo的一个属性来判断目前是否有用户信息（userInfo保底为空对象，if判断恒为真）
    let name = store.state.user.userInfo.name;
    
    /*
    	最外层if-else根据token来判断是否已经登陆
    */
    if(token) {//如果已经登录
        /*
        	这层if-else根据目标组件是不是登录页面来处理
        */
        //去登陆页面就重定向到home页面—解决了登陆后返回登录页面的问题
        if(to.path == '/login') {
            next('/home');
        }else {//登录状态下去的页面不是login，而是其它页面，这里需要处理的逻辑是：获取用户信息
            /*
            	这层if-else根据vuex中是否有用户信息来判断
            */
            //有用户信息直接转跳；没用户信息先获取用户信息再转跳
            //获取用户信息的请求放在这里才是正解，完成了到达每一个组件都自动获取用户信息的目标，同时可以删除放在home组件mounted里的请求逻辑了
            if(name) {
                next();
            }else {
                try{
                    await store.dispatch('getUserInfo');
                    next();
                } catch(error) {
                    //token失效了，获取不到用户信息：清除token，重新登录
                    await store.dispatch('userLogout');
                    next('/login');
                }
            }
        }
    }else {//如果没有登陆

        //未登录的相关逻辑还没有处理
        
        next();
    }
})

export default router;
~~~

### 知识点

* 配置路由全局前置守卫：

  ~~~js
  let router = new VueRouter({...
  })
                              
  router.beforeEach(async (to, from, next) => {
      ...
  })
  
  export default router;
  ~~~

* 前置守卫函数的参数：
  * `to`：可以访问本次路由转跳的目标路由的相关信息，比如`to.path`就是目标路由的path
  * `from`：访问本次路由转跳的原本路由的想关信息
  * `next`：放行函数，直接调用next相当于放行，去往to指向的路由路径；`next(path)`相当于修改原本的`to`，类似于重定向至`path`指定的路由。

## 52.结算页面Trade组件静态搭建

静态组件引入的逻辑：

1. pages文件夹下引入静态组件源文件
2. router/index.js路由配置文件中引入新组建，然后配置路由（简单设置路径与组件的对应关系即可）

其实路由配置项中，路径与组件的对应关系，具体表现就是路径不同，App.vue中<router-view></router-view>的呈现内容不同。

`App.vue`结构回顾：

~~~html
<template>
  <div id="app">
    <Header />
    <!-- 路由配置配置的就是这里具体呈现什么 -->
    <router-view></router-view>
    <Footer v-show="$route.meta.show"></Footer>
  </div>
</template>
~~~

## 53.Trade组件数据获取与展示

### 数据获取

1. 写请求
2. 对应仓库引入请求（trade组件新建仓库trade）并三连环
3. 组件内dispatch—vuex获取数据

### 数据展示

1. 组件获取（mapState）vuex的数据
2. 找到对应结构替换为真实数据

## 54.不使用vuex单纯用组件处理两个业务—提交订单逻辑和订单支付组件获取数据与展示

首先，我们不用vuex进行数据存储与管理，就需要在组件中直接发请求并且用data存储相关数据，这里就涉及第一个问题：组件中引入请求方法的方式，如果按需引入，哪个组件需要哪个方法就引入，这样将会非常麻烦，所以我们直接在main.js的Vue实例上挂载方法集合，就像以前挂载`$bus`时一样，我们给vue实例挂载一个`$API`。（组件的原型对象的原型对象是Vue实例对象）

我们使用`import * as All from module`就可以引入`module`模块里的所有暴露的内容集合对象`All`(All是一个对象，里面的属性是模块里具体暴露的内容)

~~~js
//引入接口文件夹里面的全部请求函数
import * as API from '@/api';

new Vue({
  router,
  store,
  beforeMount() {
    Vue.prototype.$bus = this;
    //给vue实例挂载一个$API属性，之后任意组件都可以通过"API."来调用api中定义的方法了
    Vue.prototype.$API = API;
  },
  render: h => h(App),
}).$mount('#app')
~~~

总体业务逻辑：在Trade组件中，点击提交订单之后的逻辑是先向服务器发送提交订单的请求，订单提交成功的话拿着服务器返回的订单号进行路由转跳（路由的query参数传递订单号），转跳到Pay组件，然后Pay组件里拿着订单号去发请求，获取这个订单相关的数据进行展示（就类似于当时我们点击商品之后进入商品详情页面，值传递商品id，到了详情页面再通过id获取商品的信息）

这里先回顾一下我们封装的axios，`@/api/requests`：

~~~js
...
const requests = axios.create({
    //给服务器地址增加上默认路径api
    baseURL:"/api",
    //请求超过5s就默认失败
    timeout:5000
})
...
//暴露出处理好的axios实例对象requests
export default requests;
~~~

说白了`requests`就是`axios`的一个实例对象，我们写具体的请求函数的时候用的都是`axios({相关配置})`的请求方式（还有axios.get这种方式）。这里就想总结一下`axios({相关配置})`这种请求方式的配置对象的相关格式：对于任何一个服务器接口，都有一个请求方式和url，我们用`methods`和`url`配置项指明，然后如果请求需要query参数，我们写请求方法的时候写`url`用模板字符串直接把query参数拼在url里，如果有params参数，对应一个`data`对象，里面的键值对就是`params`参数和具体值。

比如下面这个请求，也有query参数，也有params参数，params参数不管多少个，都是以参数集合`data`的形式传递给axios方法的配置对象，所以请求参数有query参数`tradeNo`对应query参数，还有`data`对应params参数。

~~~js
//提交订单的接口
export const reqSubmitOrder = (tradeNo, data) => requests({url:`/order/auth/submitOrder?tradeNo=${tradeNo}`, data, method:'post'});
~~~

Trade组件中提交订单的回调：

~~~js
async submitOrder() {
  /*
  	1.构造请求参数
  */
  let { tradeNo } = this.orderInfo;//query参数：交易编码
  let data = {//其余六个params参数
    consignee: this.userDefaultAddress.consignee,//最终收件人的名字
    consigneeTel: this.userDefaultAddress.phoneNum,//收件人手机号
    deliveryAddress: this.userDefaultAddress.fullAddress,//收件人地址
    paymentWay: "ONLINE",//支付方式
    orderComment: this.msg,//买家留言
    orderDetailList: this.orderInfo.detailArrayList,//商品清单
  }
  /*
  	2.利用this.$API发请求
  */
  let result = await this.$API.reqSubmitOrder(tradeNo,data);
  /*
  	3.根据请求成功或者失败处理相关逻辑
  */
  if(result.code == 200) {
    this.orderId = result.data;//组件内存储信息
    this.$router.push('/pay?orderId='+this.orderId);//携带订单编号跳转至支付成功页面
  }else {
    alert(result.message);
  }
}
~~~

转跳至Pay组件后，我们先通过路由的query参数获取到订单Id（orderId）：

~~~js
computed: {
  orderId() {
    return this.$route.query.orderId;
  }
},
~~~

然后应该在mounted生命周期中用orderId发请求拿到订单相关的信息，我们拿请求结果需要用到`await`，**但我们一般不会给生命周期函数添加async关键字，所以我们把发请求的逻辑封装一个async函数，然后在mounted中调用这个函数即可**。

Pay组件：

~~~js
mounted() {
  this.getPayInfo();
},
methods: {
  async getPayInfo() {
    let result = await this.$API.reqPayInfo(this.orderId);
    //如果成功，在组件当中存储数据
    if(result.code == 200) {
      this.payInfo = result.data;
    }
  }
}
~~~

组件中拿到payInfo数据之后进行展示即可。

## 55.element-ui按需引入MessageBox组件（消息弹窗）

1. `npm install element-ui `
2. Pay组件内：`import { MessageBox } from 'element-ui';`
3. 调用`MessageBox.alert`即可弹出弹窗

## 56.微信支付业务

在Pay组件中我们根据订单号发请求获取订单相关信息，服务器返回的字符串codeUrl，我们需要借助QRcode将这个字符串转化为微信支付二维码图片的地址url，然后利用MessageBox弹窗构建一个<img src="url">

`npm install qrcode`

一旦“立即支付”被点击触发了回调`open`，我们的逻辑是让MessageBox弹出呈现支付二维码，同时开启一个定时器，定时器的任务就是不断发请求（获取订单状态的请求）查看订单状态，如果订单状态为支付成功之后就转跳至支付成功的页面。然后我们可以利用弹窗配置属性`beforeClose`（`MessageBox.alert(弹窗内容, 弹窗标题,{弹窗配置属性})`）来控制弹窗的点击交互

立即支付按钮的回调：

~~~js
async open() {
  /*
  	生成弹窗
  */
  let url = await QRCode.toDataURL(this.payInfo.codeUrl);
  MessageBox.alert(`<img src=${url} />`, '请你微信支付', {
    dangerouslyUseHTMLString: true,
    //中间布局
    center:true,
    //是否显示取消按钮
    showCancelButton:true,
    //取消按钮的文本内容
    cancelButtonText:'支付遇见问题',
    //确认按钮的文本
    confirmButtonText:'已支付成功',
    //右上角的叉号没了
    showClose:false,
    //关闭弹窗之前的回调函数
    beforeClose:(type, instance, done)=>{
      //type:区分取消/确定按钮
      //当前组件实例
      //done:关闭弹窗的方法
      if(type=="cancel") {//相当于用户点击了“支付遇见问题”
        alert("请联系管理员达哥");
        //清除定时器
        clearInterval(this.timer);
        this.timer = null;
        //关闭弹出框
        done();
      }else {//用户点击了“已支付成功”
        if(this.code == 200) {
          clearInterval(this.timer);
          this.timer = null;
          done();
          this.$router.push('/paysuccess');
        }
      }
    }
  });
  /*
  	同时开启一个定时器，不停的查询支付状态
  */
  if(!this.timer) {
    this.timer = setInterval(async ()=> {
      let result = await this.$API.reqPayStatus(this.orderId);
      if(result.code == 200) {//如果支付完成
        //清除定时器
        clearInterval(this.timer);
        this.timer = null;
        //保存支付成功返回的code
        this.code = result.code;
        //关闭弹窗
        MessageBox.close();
        //跳转至下一路由
        this.$router.push('/paysuccess');
      }
    },1000)
  }
}
~~~

## 57.个人中心页二级路由配置

首先，这里对<router-view></router-view>标签与路由的关系进行总结：其实<router-view>作用很单纯，就是表明这里呈现一个路由组件（<router-view>会替换成一个路由组件），呈现那个在路由配置文件里与路径相对应的路由组件。

比如在App组件中（App.vue），结构部分上面是一个头部组件，下面是一个底部组件，中间是<router-view>代表一个路由组件，我们想让中间呈现Home组件，那就在路由配置文件中给Home组件配置一个对应的路径：

~~~js
let router = new VueRouter({
    routes: [
        ...
        {
            path: "/home",
            component: Home,
            meta: {
                show: true,
            },
        },
        ...
	],
    ...
})
~~~

**然后我们唯一要做的就是想让<router-view>显式Home组件的时候路径为“/home”即可。**比如我们新增了配置项进行重定向：

~~~js
{
    path: "/",
    redirect: "/home",
},
~~~

这样因为项目运行起来的时候默认路径就是“/”，所以自然路径就由"/"变成了"/home"，从而呈现出了Home组件。

我就在思考一个问题：既然我们只需要配置一个路径和一个路由组件就可以完成路由组件呈现和路径的一一对应，那么完全可以给所有路由都配置一个路径，**那么二级路由的应用场景是什么呢？**

二级路由的应用场景：某一个<router-view>呈现了一个路由组件，我们想更换这个路由组件的一部分（这个路由组件的某一部分是<router-view>），那么我们需要配置一个路径，让父级<router-view>呈现的同时，内部的<router-view>也呈现一个路由组件。这种情况下，路径与组件的一一对应肯定是不行的，所以我们就要用到路由配置项的`children`属性，给原本的路由组件增加子路由组件。例如个人中心页的路由配置（个人中心组件有两个子组件我的订单和团购订单，为了让Center组件中的<router-view>一开始呈现一个组件，children中还增加了一个重定向配置项）：

~~~js
{
    path: "/center",
    component: Center,
    meta: {
        show: true,
    },
    //二级路由组件
    children: [
        {
            path: "myorder",
            component: MyOrder,
        },
        {
            path: "grouporder",
            component: GroupOrder
        },
        {
            path: '/center',
            redirect: '/center/myorder'
        }
    ]
},
~~~

然后在Center组件中我们把右侧结构更换成<router-view>，然后左侧的”我的订单“和”团购订单“用<router-link>包裹，达到更换路径的效果即可

## 58.处理未登录时的全局前置路由守卫—利用路由转跳传参实现保留路由转跳意向，登陆后直接跳转至原意向页面

未登录时前置路由守卫的逻辑任务就是，有一些用户不登陆不能访问的路由，当用户去这些路由时（我们直接通过`to.path.indexOf(不能去的路由对应的字符串)`来判断是否去的是禁止的路由），都直接路由转跳到"/login"路由（利用前置路由守卫的`next`方法进行重定向），但是我们希望用户被重定向至"/login"路由登录成功时直接转跳至原本想去的路由，而不是一律都是"/home"路由。所以我们就在用户访问禁止的路由被重定向至"/login"路由的时候顺便携带query参数用来记录用户想去哪个路由。这时候我们的"/login"页面的路径是携带了query参数的，然后我们修改对应登录按钮的回调函数的逻辑，登录按钮的回调函数中，进行路由转跳之前，先判断当前路由是否有query参数，如果有的话，我们就转跳至query参数指定的路由页面，而不是"/home"。

前置路由守卫：

~~~js
router.beforeEach(async (to, from, next) => {
    
	...
    
    if(token) {//如果已经登录
        
		...
        
    }else {//如果没有登陆
        //未登录：不能去交易相关组件（trade）、支付相关组件（pay|paysuccess）、个人中心组件（center）
        //未登录时转跳如上路由时重新定位至登录组件（"/login"）
        //我们给login传递一个query参数用来记录我们原本想去的页面
        let toPath = to.path;
        if(toPath.indexOf("/trade") != -1 || toPath.indexOf("/pay") != -1 || toPath.indexOf("/center") != -1) {
            next('/login?redirect=' + toPath)
        }else {
            //去的不是上面这些路由（home|search|shopCart）,直接放行
            next();
        }
    }
})
~~~

Login组件中登录按钮的回调：

~~~js
async userLogin() {
  try {
    const { phone, password } = this;
    if( phone && password ) {
      await this.$store.dispatch('userLogin', {phone, password});
      //看当前路由中是否含有query参数，有的话说明是去其它一些不登陆不能访问的页面转跳过来登录页面的，所以就直接跳到原本想去的路由
      //没有query参数直接跳到home路由即可
      let toPath = this.$route.query.redirect || "/home";
      this.$router.push(toPath);
    }
  }catch(error) {
    alert(error.message);
  }
}
~~~

